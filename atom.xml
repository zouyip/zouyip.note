<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟的心酸历程</title>
  
  <subtitle>zyp&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zouyip.github.io/"/>
  <updated>2017-10-25T01:37:47.736Z</updated>
  <id>http://zouyip.github.io/</id>
  
  <author>
    <name>Zou Yipeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通俗地讲RESTFUL</title>
    <link href="http://zouyip.github.io/2017/10/13/%E7%94%A8%E9%80%9A%E4%BF%97%E8%AF%AD%E8%A8%80%E8%AF%B4restful/"/>
    <id>http://zouyip.github.io/2017/10/13/用通俗语言说restful/</id>
    <published>2017-10-13T06:20:33.000Z</published>
    <updated>2017-10-25T01:37:47.736Z</updated>
    
    <content type="html"><![CDATA[<p>####实现了REST规范的Web API就叫RESTful API。</p><p>简单来说：就是用url定位资源，用http描述来操作资源。</p><p>web是什么：分布式信息系统为超文本文件和其他对象（资源）提供访问入口。</p><p>资源是web架构的关键点，需要3个操作：识别，表示，交互。uri(统一资源标识符)来识别资源，html.xml,图片，视频来表示资源，通过协议与资源交互。</p><p>所以rest就是选择通过使用http协议和uri,对资源进行CRUD增删改查操作。</p><p>rest协议是面向资源的，soap是面向服务的，假如要管理一些用户，使用rest协议将用户看做是一种资源：</p><p>get  /users/{userid}  获取userid对应的user信息。     post   /users  创建一个新的user。   put  /users/{userid}  更改userid对应的user信息.</p><p>使用soap将对用户的操作看做成服务：</p><p>我们大部分项目中目前使用的是RPC风格的服务：</p><p>   rpc只能用服务本身提供的方法和接口与服务器交互，整个过程中，请求，响应和方法对于客户端都是不可见的，异构的客户端很难与服务器通信，也很难解析服务器的响应请求。</p><pre><code>restful风格的服务：整个过程采用http方法发生请求，数据采用标准格式，基于统一接口和通用载体，即使客户端和服务器采用不同的技术构建，也不会影响通信。</code></pre><p>顺便说下SOA和微服务的区别：</p><p>SOA的提出是在企业计算领域，就是要将紧耦合的系统，划分为面向业务的，粗粒度，松耦合，无状态的服务。服务发布出来供其他服务调用，一组互相依赖的服务就构成了SOA架构下的系统。</p><p>我们知道企业计算领域，如果不是交易系统的话，并发量都不是很大的，所以大多数情况下，一台服务器就容纳将许许多多的服务，这些服务采用统一的基础设施，可能都运行在一个应用服务器的进程中。虽然说是面向服务了，但还是单一的系统。</p><p>微服务：</p><p>不同的子系统采用自己的架构，那么各个服务运行自己的Web容器中，当需要增加计算能力的时候，只需要增加这个子系统或服务的实例就好了，当升级的时候，可以不影响别的子系统。这种组织方式大体上就被称作微服务架构。</p><p>微服务与SOA相比，更强调分布式系统的特性，比如横向伸缩性，服务发现，负载均衡，故障转移，高可用。互联网开发对服务治理提出了更多的要求，比如多版本，比如灰度升级，比如服务降级，比如分布式跟踪，这些都是在SOA实践中重视不够的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####实现了REST规范的Web API就叫RESTful API。&lt;/p&gt;
&lt;p&gt;简单来说：就是用url定位资源，用http描述来操作资源。&lt;/p&gt;
&lt;p&gt;web是什么：分布式信息系统为超文本文件和其他对象（资源）提供访问入口。&lt;/p&gt;
&lt;p&gt;资源是web架构的关键点，
      
    
    </summary>
    
      <category term="RESTFUL" scheme="http://zouyip.github.io/categories/RESTFUL/"/>
    
    
      <category term="RESTFUL" scheme="http://zouyip.github.io/tags/RESTFUL/"/>
    
  </entry>
  
  <entry>
    <title>异常、File</title>
    <link href="http://zouyip.github.io/2017/09/16/day19-%E5%BC%82%E5%B8%B8%E3%80%81File-%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/16/day19-异常、File-笔记/</id>
    <published>2017-09-16T11:25:20.000Z</published>
    <updated>2017-10-25T13:06:29.276Z</updated>
    
    <content type="html"><![CDATA[<p>###19.01_异常(异常的概述和分类)</p><ul><li>A:异常的概述<ul><li>异常就是Java程序在运行过程中出现的错误。</li></ul></li><li>B:异常的分类<ul><li>通过API查看Throwable</li><li>Error<ul><li>服务器宕机,数据库崩溃等</li></ul></li><li>Exception<br>C:异常的继承体系</li><li>Throwable<ul><li>Error    </li><li>Exception<ul><li>RuntimeException</li></ul></li></ul></li></ul></li></ul><p>###19.02_异常(JVM默认是如何处理异常的)</p><ul><li>A:JVM默认是如何处理异常的<ul><li>main函数收到这个问题时,有两种处理方式:</li><li>a:自己将该问题处理,然后继续运行</li><li>b:自己没有针对的处理方式,只有交给调用main的jvm来处理</li><li>jvm有一个默认的异常处理机制,就将该异常进行处理.</li><li>并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行</li></ul></li><li>B:案例演示<ul><li>JVM默认如何处理异常</li></ul></li></ul><p>###19.03_异常(try…catch的方式处理异常1)</p><ul><li>A:异常处理的两种方式<ul><li>a:try…catch…finally<ul><li>try catch</li><li>try catch finally</li><li>try finally </li></ul></li><li>b:throws</li></ul></li><li>B:try…catch处理异常的基本格式<ul><li>try…catch…finally</li></ul></li><li>C:案例演示<ul><li>try…catch的方式处理1个异常</li></ul></li></ul><p>###19.04_异常(try…catch的方式处理异常2)</p><ul><li>A:案例演示<ul><li>try…catch的方式处理多个异常</li><li>JDK7以后处理多个异常的方式及注意事项</li></ul></li></ul><p>###19.05_异常(编译期异常和运行期异常的区别)</p><ul><li><p>A:编译期异常和运行期异常的区别</p><ul><li>Java中的异常被分为两大类：编译时异常和运行时异常。</li><li><p>所有的RuntimeException类及其子类的实例被称为运行时异常，其他的异常就是编译时异常</p></li><li><p>编译时异常</p><ul><li>Java程序必须显示处理，否则程序就会发生错误，无法通过编译</li></ul></li><li>运行时异常<ul><li>无需显示处理，也可以和编译时异常一样处理</li></ul></li></ul></li><li>B:案例演示<ul><li>编译期异常和运行期异常的区别</li></ul></li></ul><p>###19.06_异常(Throwable的几个常见方法)</p><ul><li>A:Throwable的几个常见方法<ul><li>a:getMessage()<ul><li>获取异常信息，返回字符串。</li></ul></li><li>b:toString()<ul><li>获取异常类名和异常信息，返回字符串。</li></ul></li><li>c:printStackTrace()<ul><li>获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</li></ul></li></ul></li><li>B:案例演示<ul><li>Throwable的几个常见方法的基本使用</li></ul></li></ul><p>###19.07_异常(throws的方式处理异常)</p><ul><li>A:throws的方式处理异常<ul><li>定义功能方法时，需要把出现的问题暴露出来让调用者去处理。</li><li>那么就通过throws在方法上标识。</li></ul></li><li>B:案例演示<ul><li>举例分别演示编译时异常和运行时异常的抛出</li></ul></li></ul><p>###19.08_异常(throw的概述以及和throws的区别)</p><ul><li>A:throw的概述<ul><li>在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。</li></ul></li><li>B:案例演示    <ul><li>分别演示编译时异常对象和运行时异常对象的抛出</li><li>举例分别演示编译时异常和运行时异常的抛出<pre><code>* 编译时异常的抛出必须对其进行处理* 运行时异常的抛出可以处理也可以不处理</code></pre></li></ul></li><li>C:throws和throw的区别<ul><li>a:throws<ul><li>用在方法声明后面，跟的是异常类名</li><li>可以跟多个异常类名，用逗号隔开</li><li>表示抛出异常，由该方法的调用者来处理</li></ul></li><li>b:throw<ul><li>用在方法体内，跟的是异常对象名</li><li>只能抛出一个异常对象名</li><li>表示抛出异常，由方法体内的语句处理</li></ul></li></ul></li></ul><p>###19.09_异常(finally关键字的特点及作用)</p><ul><li>A:finally的特点<ul><li>被finally控制的语句体一定会执行</li><li>特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))</li></ul></li><li>B:finally的作用<ul><li>用于释放资源，在IO流操作和数据库操作中会见到</li></ul></li><li>C:案例演示<ul><li>finally关键字的特点及作用</li></ul></li></ul><p>###19.10_异常(finally关键字的面试题)</p><ul><li>A:面试题1<ul><li>final,finally和finalize的区别</li></ul></li><li>B:面试题2<ul><li>如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后。</li></ul></li></ul><p>###19.11_异常(自定义异常概述和基本使用)</p><ul><li>A:为什么需要自定义异常<ul><li>举例：人的年龄</li></ul></li><li>B:自定义异常概述<ul><li>继承自Exception</li><li>继承自RuntimeException</li></ul></li><li>C:案例演示<ul><li>自定义异常的基本使用</li></ul></li></ul><p>###19.12_异常(异常的注意事项及如何使用异常处理)</p><ul><li>A:异常注意事项<ul><li>a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)</li><li>b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常</li><li>c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws</li></ul></li><li><p>B:如何使用异常处理</p><ul><li>原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws</li><li><p>区别:</p><ul><li>后续程序需要继续运行就try</li><li>后续程序不需要继续运行就throws</li></ul></li><li><p>如果JDK没有提供对应的异常，需要自定义异常。</p></li></ul></li></ul><p>###19.13_异常(练习)</p><ul><li>键盘录入一个int类型的整数,对其求二进制表现形式<ul><li>如果录入的整数过大,给予提示,录入的整数过大请重新录入一个整数BigInteger</li><li>如果录入的是小数,给予提示,录入的是小数,请重新录入一个整数</li><li>如果录入的是其他字符,给予提示,录入的是非法字符,请重新录入一个整数</li></ul></li></ul><p>###19.14_File类(File类的概述和构造方法)</p><ul><li>A:File类的概述<ul><li>File更应该叫做一个路径<ul><li>文件路径或者文件夹路径  </li><li>路径分为绝对路径和相对路径</li><li>绝对路径是一个固定的路径,从盘符开始</li><li>相对路径相对于某个位置,在eclipse下是指当前项目下,在dos下</li></ul></li><li>查看API指的是当前路径</li><li>文件（路径名）或目录路径名的抽象表示形式</li></ul></li><li>B:构造方法<ul><li>File(String pathname)：根据一个路径得到File对象</li><li>File(String parent, String child):根据一个目录和一个子文件/目录得到File对象</li><li>File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象</li></ul></li><li>C:案例演示<ul><li>File类的构造方法</li></ul></li></ul><p>###19.15_File类(File类的创建功能)</p><ul><li>A:创建功能<ul><li>public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了</li><li>public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了</li><li>public boolean mkdirs():创建多级文件夹。</li></ul></li><li><p>B:案例演示</p><ul><li><p>File类的创建功能</p></li><li><p>注意事项：</p><ul><li>如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。</li></ul></li></ul></li></ul><p>###19.16_File类(File类的重命名和删除功能)</p><ul><li>A:重命名和删除功能<ul><li>public boolean renameTo(File dest):把文件重命名为指定的文件路径</li><li>public boolean delete():删除文件或者文件夹</li></ul></li><li>B:重命名注意事项<ul><li>如果路径名相同，就是改名。</li><li>如果路径名不同，就是改名并剪切。</li></ul></li><li>C:删除注意事项：<ul><li>Java中的删除不走回收站。</li><li>要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹</li></ul></li></ul><p>###19.17_File类(File类的判断功能)</p><ul><li>A:判断功能<ul><li>public boolean isDirectory():判断是否是目录</li><li>public boolean isFile():判断是否是文件</li><li>public boolean exists():判断是否存在</li><li>public boolean canRead():判断是否可读</li><li>public boolean canWrite():判断是否可写</li><li>public boolean isHidden():判断是否隐藏</li></ul></li><li>B:案例演示<ul><li>File类的判断功能</li></ul></li></ul><p>###19.18_File类(File类的获取功能)</p><ul><li>A:获取功能<ul><li>public String getAbsolutePath()：获取绝对路径</li><li>public String getPath():获取路径（获取的是创建对象时构造方法里的路径）</li><li>public String getName():获取名称 （获取文件或者文件夹的名字）</li><li>public long length():获取长度。字节数</li><li>public long lastModified():获取最后一次的修改时间，毫秒值</li><li>public String[] list():获取指定目录下的所有文件或者文件夹的名称数组 （获取的是文件名）</li><li>public File[] listFiles():获取指定目录下的所有文件或者文件夹的 File数组 （注意：获取的的File对象，可以拿来操作）</li></ul></li><li>B:案例演示<ul><li>File类的获取功能</li></ul></li></ul><p>###19.19_File类(输出指定目录下指定后缀的文件名)</p><ul><li>A:案例演示<ul><li>需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称</li></ul></li></ul><p>###19.20_File类(文件名称过滤器的概述及使用)</p><ul><li>A:文件名称过滤器的概述<ul><li>public String[] list(FilenameFilter filter)</li><li>public File[] listFiles(FileFilter filter)</li></ul></li><li>B:文件名称过滤器的使用<ul><li>需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称</li></ul></li><li>C:源码分析<ul><li>带文件名称过滤器的list()方法的源码</li></ul></li></ul><p>###19.21_File类(递归)</p><ul><li>5的阶乘        </li></ul><p>###19.22_day19总结<br>把今天的知识点总结一遍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###19.01_异常(异常的概述和分类)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:异常的概述&lt;ul&gt;
&lt;li&gt;异常就是Java程序在运行过程中出现的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:异常的分类&lt;ul&gt;
&lt;li&gt;通过API查看Throwable&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="exception" scheme="http://zouyip.github.io/tags/exception/"/>
    
      <category term="File" scheme="http://zouyip.github.io/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>Map</title>
    <link href="http://zouyip.github.io/2017/09/14/day18-Map%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/14/day18-Map笔记/</id>
    <published>2017-09-14T07:25:20.000Z</published>
    <updated>2017-10-25T03:52:52.651Z</updated>
    
    <content type="html"><![CDATA[<p>###18.01_集合框架(Map集合概述和特点)</p><ul><li>A:Map接口概述<ul><li>查看API可以知道：<ul><li>将键映射到值的对象</li><li>一个映射不能包含重复的键</li><li>每个键最多只能映射到一个值</li></ul></li></ul></li><li>B:Map接口和Collection接口的不同<ul><li>Map是双列的,Collection是单列的</li><li>Map的键唯一,Collection的子体系Set是唯一的</li><li>Map集合的数据结构只针对键有效，跟值无关;Collection集合的数据结构是针对元素有效</li></ul></li></ul><p>###18.02_集合框架(Map集合的功能概述)</p><ul><li>A:Map集合的功能概述<ul><li>a:添加功能<ul><li>V put(K key,V value):添加元素。<ul><li>如果键是第一次存储，就直接存储元素，返回null</li><li>如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值</li></ul></li></ul></li><li>b:删除功能<ul><li>void clear():移除所有的键值对元素</li><li>V remove(Object key)：根据键删除键值对元素，并把值返回</li></ul></li><li>c:判断功能<ul><li>boolean containsKey(Object key)：判断集合是否包含指定的键</li><li>boolean containsValue(Object value):判断集合是否包含指定的值</li><li>boolean isEmpty()：判断集合是否为空</li></ul></li><li>d:获取功能<ul><li>Set<map.entry<k,v>&gt; entrySet():</map.entry<k,v></li><li>V get(Object key):根据键获取值</li><li>Set<k> keySet():获取集合中所有键的集合</k></li><li>Collection<v> values():获取集合中所有值的集合</v></li></ul></li><li>e:长度功能<ul><li>int size()：返回集合中的键值对的个数</li></ul></li></ul></li></ul><p>###18.03_集合框架(Map集合的遍历之键找值)</p><ul><li>A:键找值思路：<ul><li>获取所有键的集合</li><li>遍历键的集合，获取到每一个键</li><li>根据键找值</li></ul></li><li><p>B:案例演示</p><ul><li><p>Map集合的遍历之键找值</p><pre><code>HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;();hm.put(&quot;张三&quot;, 23);hm.put(&quot;李四&quot;, 24);hm.put(&quot;王五&quot;, 25);hm.put(&quot;赵六&quot;, 26);/*Set&lt;String&gt; keySet = hm.keySet();            //获取集合中所有的键Iterator&lt;String&gt; it = keySet.iterator();    //获取迭代器while(it.hasNext()) {                        //判断单列集合中是否有元素    String key = it.next();                    //获取集合中的每一个元素,其实就是双列集合中的键    Integer value = hm.get(key);            //根据键获取值    System.out.println(key + &quot;=&quot; + value);    //打印键值对}*/for(String key : hm.keySet()) {                //增强for循环迭代双列集合第一种方式    System.out.println(key + &quot;=&quot; + hm.get(key));}</code></pre></li></ul></li></ul><p>###18.04_集合框架(Map集合的遍历之键值对对象找键和值)</p><ul><li>A:键值对对象找键和值思路：<ul><li>获取所有键值对对象的集合</li><li>遍历键值对对象的集合，获取到每一个键值对对象</li><li>根据键值对对象找键和值</li></ul></li><li><p>B:案例演示</p><ul><li><p>Map集合的遍历之键值对对象找键和值</p><pre><code>HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;();hm.put(&quot;张三&quot;, 23);hm.put(&quot;李四&quot;, 24);hm.put(&quot;王五&quot;, 25);hm.put(&quot;赵六&quot;, 26);/*Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = hm.entrySet();    //获取所有的键值对象的集合Iterator&lt;Entry&lt;String, Integer&gt;&gt; it = entrySet.iterator();//获取迭代器while(it.hasNext()) {    Entry&lt;String, Integer&gt; en = it.next();                //获取键值对对象    String key = en.getKey();                                //根据键值对对象获取键    Integer value = en.getValue();                            //根据键值对对象获取值    System.out.println(key + &quot;=&quot; + value);}*/for(Entry&lt;String,Integer&gt; en : hm.entrySet()) {    System.out.println(en.getKey() + &quot;=&quot; + en.getValue());}</code></pre></li></ul></li></ul><p>C:源码分析</p><p>###18.05_集合框架(HashMap集合键是Student值是String的案例)</p><ul><li>A:案例演示<ul><li>HashMap集合键是Student值是String的案例</li></ul></li></ul><p>###18.06_集合框架(LinkedHashMap的概述和使用)</p><ul><li>A:案例演示<ul><li>LinkedHashMap的特点<ul><li>底层是链表实现的，可以保证怎么存就怎么取</li></ul></li></ul></li></ul><p>###18.07_集合框架(TreeMap集合键是Student值是String的案例)</p><ul><li>A:案例演示<ul><li>TreeMap集合：键是Student，值是String的案例</li></ul></li></ul><p>###18.08_集合框架(统计字符串中每个字符出现的次数)</p><ul><li><p>A:案例演示</p><ul><li><p>需求：统计字符串中每个字符出现的次数</p><pre><code>String str = &quot;aaaabbbcccccccccc&quot;;char[] arr = str.toCharArray();                        //将字符串转换成字符数组HashMap&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;();    //创建双列集合存储键和值for(char c : arr) {                                    //遍历字符数组    /*if(!hm.containsKey(c)) {                        //如果不包含这个键        hm.put(c, 1);                                //就将键和值为1添加    }else {                                            //如果包含这个键        hm.put(c, hm.get(c) + 1);                    //就将键和值再加1添加进来    }    //hm.put(c, !hm.containsKey(c) ? 1 : hm.get(c) + 1);    Integer i = !hm.containsKey(c) ? hm.put(c, 1) : hm.put(c, hm.get(c) + 1);            }for (Character key : hm.keySet()) {                    //遍历双列集合    System.out.println(key + &quot;=&quot; + hm.get(key));}</code></pre></li></ul></li></ul><p>###18.09_集合框架(集合嵌套之HashMap嵌套HashMap)</p><ul><li>A:案例演示<ul><li>集合嵌套之HashMap嵌套HashMap</li></ul></li></ul><p>###18.10_集合框架(HashMap和Hashtable的区别)</p><ul><li>A:面试题<ul><li>HashMap和Hashtable的区别<ul><li>Hashtable是JDK1.0版本出现的,是线程安全的,效率低,HashMap是JDK1.2版本出现的,是线程不安全的,效率高</li><li>Hashtable不可以存储null键和null值,HashMap可以存储null键和null值</li></ul></li></ul></li><li>B:案例演示    <ul><li>HashMap和Hashtable的区别</li></ul></li></ul><p>###18.11_集合框架(Collections工具类的概述和常见方法讲解)</p><ul><li>A:Collections类概述<ul><li>针对集合操作 的工具类</li></ul></li><li>B:Collections成员方法</li><li><pre><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key)public static &lt;T&gt; T max(Collection&lt;?&gt; coll)public static void reverse(List&lt;?&gt; list)public static void shuffle(List&lt;?&gt; list)</code></pre></li></ul><p>###18.12_集合框架(模拟斗地主洗牌和发牌)</p><ul><li><p>A:案例演示</p><ul><li><p>模拟斗地主洗牌和发牌，牌没有排序</p><pre><code>//买一副扑克String[] num = {&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;};String[] color = {&quot;方片&quot;,&quot;梅花&quot;,&quot;红桃&quot;,&quot;黑桃&quot;};ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;();for(String s1 : color) {    for(String s2 : num) {        poker.add(s1.concat(s2));    }}poker.add(&quot;小王&quot;);poker.add(&quot;大王&quot;);//洗牌Collections.shuffle(poker);//发牌ArrayList&lt;String&gt; gaojin = new ArrayList&lt;&gt;();ArrayList&lt;String&gt; longwu = new ArrayList&lt;&gt;();ArrayList&lt;String&gt; me = new ArrayList&lt;&gt;();ArrayList&lt;String&gt; dipai = new ArrayList&lt;&gt;();for(int i = 0; i &lt; poker.size(); i++) {    if(i &gt;= poker.size() - 3) {        dipai.add(poker.get(i));    }else if(i % 3 == 0) {        gaojin.add(poker.get(i));    }else if(i % 3 == 1) {        longwu.add(poker.get(i));    }else {        me.add(poker.get(i));    }}//看牌System.out.println(gaojin);System.out.println(longwu);System.out.println(me);System.out.println(dipai);</code></pre></li></ul></li></ul><p>###18.13_集合框架(模拟斗地主洗牌和发牌并对牌进行排序的原理图解)</p><ul><li>A:画图演示<ul><li>画图说明排序原理</li></ul></li></ul><p>###18.14_集合框架(模拟斗地主洗牌和发牌并对牌进行排序的代码实现)</p><ul><li>A:案例演示<ul><li>模拟斗地主洗牌和发牌并对牌进行排序的代码实现</li></ul></li><li><pre><code>    //买一副牌    String[] num = {&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;};    String[] color = {&quot;方片&quot;,&quot;梅花&quot;,&quot;红桃&quot;,&quot;黑桃&quot;};    HashMap&lt;Integer, String&gt; hm = new HashMap&lt;&gt;();            //存储索引和扑克牌    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();            //存储索引    int index = 0;                                            //索引的开始值    for(String s1 : num) {        for(String s2 : color) {            hm.put(index, s2.concat(s1));                    //将索引和扑克牌添加到HashMap中            list.add(index);                                //将索引添加到ArrayList集合中            index++;                ////自动装箱了，所以会改变index的值        }    }    hm.put(index, &quot;小王&quot;);    list.add(index);    index++;    hm.put(index, &quot;大王&quot;);    list.add(index);    //洗牌    Collections.shuffle(list);    //发牌    TreeSet&lt;Integer&gt; gaojin = new TreeSet&lt;&gt;();    TreeSet&lt;Integer&gt; longwu = new TreeSet&lt;&gt;();    TreeSet&lt;Integer&gt; me = new TreeSet&lt;&gt;();    TreeSet&lt;Integer&gt; dipai = new TreeSet&lt;&gt;();    for(int i = 0; i &lt; list.size(); i++) {        if(i &gt;= list.size() - 3) {            dipai.add(list.get(i));                         //将list集合中的索引添加到TreeSet集合中会自动排序        }else if(i % 3 == 0) {            gaojin.add(list.get(i));        }else if(i % 3 == 1) {            longwu.add(list.get(i));        }else {            me.add(list.get(i));        }    }    //看牌    lookPoker(&quot;高进&quot;, gaojin, hm);    lookPoker(&quot;龙五&quot;, longwu, hm);    lookPoker(&quot;冯佳&quot;, me, hm);    lookPoker(&quot;底牌&quot;, dipai, hm);}public static void lookPoker(String name,TreeSet&lt;Integer&gt; ts,HashMap&lt;Integer, String&gt; hm) {    System.out.print(name + &quot;的牌是:&quot;);    for (Integer index : ts) {        System.out.print(hm.get(index) + &quot; &quot;);    }    System.out.println();}</code></pre><p>###18.15_集合框架(泛型固定下边界)</p></li><li>? super E</li></ul><p>###18.16_day18总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###18.01_集合框架(Map集合概述和特点)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:Map接口概述&lt;ul&gt;
&lt;li&gt;查看API可以知道：&lt;ul&gt;
&lt;li&gt;将键映射到值的对象&lt;/li&gt;
&lt;li&gt;一个映射不能包含重复的键&lt;/li&gt;
&lt;li&gt;每个键最多只能映射到一个值&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Map" scheme="http://zouyip.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Set</title>
    <link href="http://zouyip.github.io/2017/09/12/day17-Set%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/12/day17-Set笔记/</id>
    <published>2017-09-12T11:25:20.000Z</published>
    <updated>2017-10-25T01:50:29.982Z</updated>
    
    <content type="html"><![CDATA[<p>###17.01_集合框架(HashSet存储字符串并遍历)</p><ul><li>A:Set集合概述及特点  Set集合,无索引,不可以重复,无序(存取不一致)<ul><li>通过API查看即可</li></ul></li><li><p>B:案例演示</p><ul><li>HashSet存储字符串并遍历   </li><li><pre><code> HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();boolean b1 = hs.add(&quot;a&quot;);boolean b2 = hs.add(&quot;a&quot;);            //当存储不成功的时候,返回falseSystem.out.println(b1);System.out.println(b2);for(String s : hs) {    System.out.println(s);}</code></pre></li></ul></li></ul><p>###17.02_集合框架(HashSet存储自定义对象保证元素唯一性)        <em>HashSet的继承体系中有重写toString方法                                                              </em>只要能用迭代器迭代的,就可以使用增强for循环遍历</p><ul><li><p>A:案例演示</p><ul><li><p>存储 自定义对象 ，并保证元素唯一性。</p><pre><code>HashSet&lt;Person&gt; hs = new HashSet&lt;&gt;();hs.add(new Person(&quot;张三&quot;, 23));hs.add(new Person(&quot;张三&quot;, 23));hs.add(new Person(&quot;李四&quot;, 23));hs.add(new Person(&quot;李四&quot;, 23));hs.add(new Person(&quot;王五&quot;, 23));hs.add(new Person(&quot;赵六&quot;, 23));</code></pre></li></ul></li><li>注意：通过重写hashCode()和equals()方法来保证HashSet存储自定义对象元素的唯一性！！！<pre><code>如果不重写的话，那么new出来的是不同的对象（地址值不同），所以会将元素值相同的对象视为不同的对象存储在HashSet集合中。要使HashSet存储自定义对象保证元素唯一性，则需要通过重写hashCode()和equals()方法来保证HashSet存储自定义对象元素的唯一性！！！重写hashCode（）方法返回同一个值（值相同时），才会调用重写的equals（）方法。</code></pre>###17.03_集合框架(HashSet存储自定义对象保证元素唯一性图解及代码优化)</li><li>A:画图演示<ul><li>画图说明比较过程</li></ul></li><li>B:代码优化<ul><li>为了减少比较，优化hashCode()代码写法。</li><li>最终版就是自动生成即可。</li></ul></li></ul><p>###17.04_集合框架(HashSet如何保证元素唯一性的原理)</p><ul><li>1.HashSet原理<ul><li>我们使用Set集合都是需要去掉重复元素的, 如果在存储的时候逐个equals()比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用equals()方法的次数</li><li>当HashSet调用add()方法存储对象的时候, 先调用对象的hashCode()方法得到一个哈希值, 然后在集合中查找是否有哈希值相同的对象<ul><li>如果没有哈希值相同的对象就直接存入集合</li><li>如果有哈希值相同的对象, 就和哈希值相同的对象逐个进行equals()比较,比较结果为false就存入, true则不存</li></ul></li></ul></li><li>2.将自定义类的对象存入HashSet去重复<ul><li>类中必须重写hashCode()和equals()方法  （注意：如果不重写的话就不能达到去重的效果，可能出现重复的元素）</li><li>hashCode(): 属性相同的对象返回值必须相同, 属性不同的返回值尽量不同(提高效率)</li><li>equals(): 属性相同返回true, 属性不同返回false,返回false的时候存储</li></ul></li></ul><p>###17.05_集合框架(LinkedHashSet的概述和使用)</p><ul><li>LinkedHashSet<ul><li>底层是链表实现的,是set集合中 唯一一个能保证怎么存就怎么取的集合对象</li><li>因为是HashSet的子类,所以也是保证元素唯一的,与HashSet的原理一样</li></ul></li><li>A:LinkedHashSet的特点</li><li>B:案例演示<ul><li>LinkedHashSet的特点<ul><li>可以保证怎么存就怎么取 </li></ul></li></ul></li></ul><p>###17.06_集合框架(产生10个1-20之间的随机数要求随机数不能重复)</p><ul><li><p>A:案例演示</p><ul><li>需求：编写一个程序，获取10个1至20的随机数，要求随机数不能重复。并把最终的随机数输出到控制台。</li><li><pre><code>HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();        //创建集合对象Random r = new Random();                    //创建随机数对象while(hs.size() &lt; 10) {    int num = r.nextInt(20) + 1;            //生成1到20的随机数    hs.add(num);}for (Integer integer : hs) {                //遍历集合    System.out.println(integer);            //打印每一个元素}</code></pre></li></ul></li></ul><p>###17.07_集合框架(练习)</p><ul><li><p>使用Scanner从键盘读取一行输入,去掉其中重复字符, 打印出不同的那些字符</p><ul><li><p>aaaabbbcccddd</p><pre><code>Scanner sc = new Scanner(System.in);            //创建键盘录入对象System.out.println(&quot;请输入一行字符串:&quot;);String line = sc.nextLine();                    //将键盘录入的字符串存储在line中char[] arr = line.toCharArray();                //将字符串转换成字符数组HashSet&lt;Character&gt; hs = new HashSet&lt;&gt;();        //创建HashSet集合对象for(char c : arr) {                                //遍历字符数组    hs.add(c);                                    //将字符数组中的字符添加到集合中}for (Character ch : hs) {                        //遍历集合    System.out.println(ch);}</code></pre><p>###17.08_集合框架(练习)</p></li></ul></li><li>将集合中的重复元素去掉</li><li><pre><code>public static void main(String[] args) {    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add(&quot;a&quot;);    list.add(&quot;a&quot;);    list.add(&quot;a&quot;);    list.add(&quot;b&quot;);    list.add(&quot;b&quot;);    list.add(&quot;b&quot;);    list.add(&quot;b&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    System.out.println(list);    System.out.println(&quot;去除重复后:&quot;);    getSingle(list);    System.out.println(list);}/* * 将集合中的重复元素去掉 * 1,void * 2,List&lt;String&gt; list */public static void getSingle(List&lt;String&gt; list) {    LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;&gt;();    lhs.addAll(list);                                    //将list集合中的所有元素添加到lhs    list.clear();                                        //清空原集合    list.addAll(lhs);                                    //将去除重复的元素添回到list中}</code></pre></li></ul><p>###17.09_集合框架(TreeSet存储Integer类型的元素并遍历)<em>**</em>TreeSet的底层数据结构是二叉树，</p><ul><li>A:案例演示<ul><li>TreeSet存储Integer类型的元素并遍历</li></ul></li></ul><p>###17.10_集合框架(TreeSet存储自定义对象)</p><ul><li>A:案例演示<ul><li>存储Person对象</li></ul></li></ul><p>###17.11_集合框架(TreeSet保证元素唯一和自然排序的原理（按二叉树的读取方式读取进行排序）和图解)<br>                    根据compareTo方法的返回值来实现的。</p><ul><li>A:画图演示<ul><li>TreeSet保证元素唯一和自然排序的原理和图解</li></ul></li></ul><p>###17.12_集合框架(TreeSet存储自定义对象并遍历练习1)</p><ul><li>A:案例演示<ul><li>TreeSet存储自定义对象并遍历练习1(按照姓名排序)</li></ul></li></ul><p>###17.13_集合框架(TreeSet存储自定义对象并遍历练习2)</p><ul><li>A:案例演示<ul><li>TreeSet存储自定义对象并遍历练习2(按照姓名的长度排序)</li></ul></li></ul><p>###17.14_集合框架(TreeSet保证元素唯一和比较器排序的原理及代码实现)</p><ul><li>A:案例演示<ul><li>TreeSet保证元素唯一和比较器排序的原理及代码实现</li></ul></li></ul><p>###17.15_集合框架(TreeSet原理)</p><ul><li>1.特点<ul><li>TreeSet是用来排序的, 可以指定一个顺序, 对象存入之后会按照指定的顺序排列</li></ul></li><li>2.使用方式<ul><li>a.自然顺序(Comparable)<ul><li>TreeSet类的add()方法中会把存入的对象提升为Comparable类型</li><li>调用对象的compareTo()方法和集合中的对象比较</li><li>根据compareTo()方法返回的结果进行存储</li></ul></li><li>b.比较器顺序(Comparator)<ul><li>创建TreeSet的时候可以制定 一个Comparator</li><li>如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序</li><li>add()方法内部会自动调用Comparator接口中compare()方法排序</li><li>调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数</li></ul></li><li>c.两种方式的区别<ul><li>TreeSet构造函数什么都不传, 默认按照类中Comparable的顺序(没有就报错ClassCastException)</li><li>TreeSet如果传入Comparator, 就优先按照Comparator</li></ul></li></ul></li></ul><p>###17.16_集合框架(练习)</p><ul><li><p>在一个集合中存储了无序并且重复的字符串,定义一个方法,让其有序(字典顺序),而且还不能去除重复</p><pre><code>public static void main(String[] args) {    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add(&quot;ccc&quot;);    list.add(&quot;ccc&quot;);    list.add(&quot;aaa&quot;);    list.add(&quot;aaa&quot;);    list.add(&quot;bbb&quot;);    list.add(&quot;ddd&quot;);    list.add(&quot;ddd&quot;);    sort(list);    System.out.println(list);}/* * 对集合中的元素排序,并保留重复 * 1,void * 2,List&lt;String&gt; list */public static void sort(List&lt;String&gt; list) {    TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() {        //定义比较器(new Comparator(){}是Comparator的子类对象)        @Override        public int compare(String s1, String s2) {                        //重写compare方法            int num = s1.compareTo(s2);                                    //比较内容            return num == 0 ? 1 : num;                                    //如果内容一样返回一个不为0的数字即可        }    });    ts.addAll(list);                                                    //将list集合中的所有元素添加到ts中    list.clear();                                                        //清空list    list.addAll(ts);                                                    //将ts中排序并保留重复的结果在添加到list中}</code></pre></li></ul><p>###17.17_集合框架(练习)</p><ul><li><p>从键盘接收一个字符串, 程序对其中所有字符进行排序,例如键盘输入: helloitcast程序打印:acehillostt</p><pre><code>Scanner sc = new Scanner(System.in);            //创建键盘录入对象System.out.println(&quot;请输入一行字符串:&quot;);String line = sc.nextLine();                    //将键盘录入的字符串存储在line中char[] arr = line.toCharArray();                //将字符串转换成字符数组TreeSet&lt;Character&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Character&gt;() {    @Override    public int compare(Character c1, Character c2) {        //int num = c1.compareTo(c2);        int num = c1 - c2;                    //自动拆箱        return num == 0 ? 1 : num;    }});for(char c : arr) {    ts.add(c);}for(Character ch : ts) {    System.out.print(ch);}</code></pre><p>###17.18_集合框架(练习)</p></li><li><p>程序启动后, 可以从键盘输入接收多个整数, 直到输入quit时结束输入. 把所有输入的整数倒序排列打印.</p><pre><code>Scanner sc = new Scanner(System.in);        //创建键盘录入对象System.out.println(&quot;请输入:&quot;);TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Integer&gt;() {//将比较器传给TreeSet的构造方法    @Override    public int compare(Integer i1, Integer i2) {        //int num = i2 - i1;                    //自动拆箱        int num = i2.compareTo(i1);        return num == 0 ? 1 : num;    }});while(true) {    String line = sc.nextLine();            //将键盘录入的字符串存储在line中    if(&quot;quit&quot;.equals(line))                    //如果字符串常量和变量比较,常量放前面,这样不会出现空指针异常,变量里面可能存储null        break;    try {        int num = Integer.parseInt(line);        //将数字字符串转换成数字        ts.add(num);    } catch (Exception e) {        System.out.println(&quot;您录入的数据有误,请输入一个整数&quot;);    }}for (Integer i : ts) {                        //遍历TreeSet集合    System.out.println(i);}</code></pre><p>###17.19_集合框架(键盘录入学生信息按照总分排序后输出在控制台)</p></li><li><p>A:案例演示</p><ul><li><p>需求：键盘录入5个学生信息(姓名,语文成绩,数学成绩,英语成绩),按照总分从高到低输出到控制台。</p><pre><code>Scanner sc = new Scanner(System.in);System.out.println(&quot;请输入5个学生成绩格式是:(姓名,语文成绩,数学成绩,英语成绩)&quot;);TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() {    @Override    public int compare(Student s1, Student s2) {        int num = s2.getSum() - s1.getSum();            //根据学生的总成绩降序排列        return num == 0 ? 1 : num;    }});while(ts.size() &lt; 5) {    String line = sc.nextLine();    try {        String[] arr = line.split(&quot;,&quot;);        int chinese = Integer.parseInt(arr[1]);                //转换语文成绩        int math = Integer.parseInt(arr[2]);                //转换数学成绩        int english = Integer.parseInt(arr[3]);                //转换英语成绩        ts.add(new Student(arr[0], chinese, math, english));    } catch (Exception e) {        System.out.println(&quot;录入格式有误,输入5个学生成绩格式是:(姓名,语文成绩,数学成绩,英语成绩&quot;);    }}System.out.println(&quot;排序后的学生成绩是:&quot;);for (Student s : ts) {    System.out.println(s);}</code></pre></li></ul></li></ul><p>###17.20_day17总结</p><ul><li>1.List<ul><li>a.普通for循环, 使用get()逐个获取</li><li>b.调用iterator()方法得到Iterator, 使用hasNext()和next()方法</li><li>c.增强for循环, 只要可以使用Iterator的类都可以用</li><li>d.Vector集合可以使用Enumeration的hasMoreElements()和nextElement()方法</li></ul></li><li>2.Set<ul><li>a.调用iterator()方法得到Iterator, 使用hasNext()和next()方法</li><li>b.增强for循环, 只要可以使用Iterator的类都可以用</li></ul></li><li><p>3.普通for循环,迭代器,增强for循环是否可以在遍历的过程中删除 </p><p>  哈希表，是一种数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。<br>  这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>二、Hashtable、HashMap、ConcurrentHashMap、LinkedHashMap、TreeMap区别</p></li></ul><p>　　Hashtable是一个包含单向链表的二维数组，其数据结构的数组中是Entry<k,v>存储，entry对象。Hashtable有洁癖，<br>    不允许存入其中的key或者value为null。Hashtable是线程安全的，所有的方法均用synchronized修饰，这样在任一时刻，<br>    只有一个线程可以写Hashtable，因此，对于频繁写操作的业务逻辑，诸如写excel表等时候，速度会非常慢。</k,v></p><p>　　HashMap是最常用的Map型数据结构，它根据键的hashCode()值存储数据。HashMap允许一个key为null,允许多个value为空，<br>    HashMap不支持线程的同步，即可能会出现在同一时刻有多个线程同时写HashMap,会产生数据的不一致。如果在修改代码的过程中，<br>    需要给HashMap限制为线程同步的，可以采用Collections.synchronizedMap(map);方法使得HashMap可以同步。</p><p>　　ConcurrentHashMap是基于这样的考虑：降低锁的粒度。在Hashtable中的关键字是使用synchronized基于整张表结构的，锁的粒度太大，<br>    它每次通过锁住整张表让线程独占，来保证安全性。</p><p>　　LinkedHashMap保存了记录的插入顺序，在使用Iterator遍历LinkedHashMap的时候，先得到的记录肯定是先插入的。<br>    在遍历的时候会比HashMap慢，因为HashMap是以O(1)来设计存取的。并且LinkedHashMap继承自HashMap，拥有它的全部特性。</p><p>　　TreeMap是基于红黑树实现的，它是一种有序的存储结构，并且程序员可以自己定义排序器。TreeMap默认会按存入的键值key来排序，<br>    默认是按升序排序，当然也可以指定排序的比较器。TreeMap同样有洁癖，不允许存入null值。使用Iterator遍历出来的TreeMap往往是有序的。</p><p>　　总结：常用HashMap，允许null插入；有两个子类：ConcurrentHashMap和LinkedHashMap。前者用来弥补线程安全，后者用来弥补有序。<br>    此外还有Hashtable和TreeMap。虽然CouncurrentHashMap性能明显优于Hashtable，但是并不能完全取代Hashtable，<br>    因为遍历ConcurrentHashMap的迭代器是弱一致的。TreeMap数据结构则可以帮助我们得到一个有序的结果，适用于需要输出排序结果的场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###17.01_集合框架(HashSet存储字符串并遍历)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:Set集合概述及特点  Set集合,无索引,不可以重复,无序(存取不一致)&lt;ul&gt;
&lt;li&gt;通过API查看即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B:案例演示&lt;/p&gt;

      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Set" scheme="http://zouyip.github.io/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList，泛型</title>
    <link href="http://zouyip.github.io/2017/09/12/day16-ArrayList%E3%80%81%E6%B3%9B%E5%9E%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/12/day16-ArrayList、泛型笔记/</id>
    <published>2017-09-12T08:53:30.000Z</published>
    <updated>2017-10-25T01:49:34.123Z</updated>
    
    <content type="html"><![CDATA[<p>###16.01_集合框架(去除ArrayList中重复字符串元素方式)(掌握)</p><ul><li><p>A:案例演示</p><ul><li>需求：ArrayList去除集合中字符串的重复值(字符串的内容相同)</li><li><p>思路：创建新集合方式</p><pre><code>/** *  A:案例演示 * 需求：ArrayList去除集合中字符串的重复值(字符串的内容相同) * 思路：创建新集合方式 */public static void main(String[] args) {    ArrayList list = new ArrayList();    list.add(&quot;a&quot;);    list.add(&quot;a&quot;);    list.add(&quot;b&quot;);    list.add(&quot;b&quot;);    list.add(&quot;b&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    System.out.println(list);    ArrayList newList = getSingle(list);    System.out.println(newList);}/* * 去除重复 * 1,返回ArrayList * 2,参数列表ArrayList */public static ArrayList getSingle(ArrayList list) {    ArrayList newList = new ArrayList();            //创建一个新集合    Iterator it = list.iterator();                    //获取迭代器    while(it.hasNext()) {                            //判断老集合中是否有元素        String temp = (String)it.next();            //将每一个元素临时记录住        if(!newList.contains(temp)) {                //如果新集合中不包含该元素            newList.add(temp);                        //将该元素添加到新集合中        }    }    return newList;                                    //将新集合返回}</code></pre><p>###16.02_集合框架(去除ArrayList中重复自定义对象元素)(掌握)</p></li></ul></li><li>A:案例演示<ul><li>需求：ArrayList去除集合中自定义对象元素的重复值(对象的成员变量值相同)</li></ul></li><li>B:注意事项<ul><li>重写equals()方法<br>  contains方法判断是否包含,底层依赖的是equals方法.<br>  remove方法判断是否删除,底层依赖的是equals方法.</li></ul></li></ul><p>###16.03_集合框架(LinkedList的特有功能)(掌握)</p><ul><li>A:LinkedList类概述</li><li><p>B:LinkedList类特有功能</p><ul><li>public void addFirst(E e)及addLast(E e)    在头部添加元素 或在尾部添加元素 </li><li>public E getFirst()及getLast()</li><li>public E removeFirst()及public E removeLast()</li><li><p>public E get(int index);</p><p>LinkedList：</p><p>  *特有方法：　　</p><pre><code>*addFirst();在头部添加元素      addLast();在尾部添加元素*getFirst(); getLast(); 获取元素但不删除元素。如果集合中没有元素，会出现NoSuchElementException*removeFirst();   removeLast(); 获取元素但是删除元素。如果集合中没有元素，会出现NoSuchElementException*在JDK1.6出现了替代方法*offerFirst(); offerLast();*peekFirst(); peekLast(); 获取元素，但是元素不被删除。如果集合中没有元素，会返回null*pollFirst(); pollLast(); 获取元素，但是元素被删除。如果集合中没有元素，会返回null</code></pre></li></ul></li></ul><p>###16.04_集合框架(栈和队列数据结构)(掌握)</p><ul><li>栈<ul><li>先进后出 </li></ul></li><li>队列<ul><li>先进先出</li></ul></li></ul><p>###16.05_集合框架(用LinkedList模拟栈数据结构的集合并测试)(掌握)</p><ul><li><p>A:案例演示</p><ul><li>需求：请用LinkedList模拟栈数据结构的集合，并测试</li><li>创建一个类将Linked中的方法封装</li><li><pre><code>public class Stack {    private LinkedList list = new LinkedList();        //创建LinkedList对象    public void in(Object obj) {        list.addLast(obj);                            //封装addLast()方法    }    public Object out() {        return list.removeLast();                    //封装removeLast()方法    }    public boolean isEmpty() {        return list.isEmpty();                        //封装isEmpty()方法    }}</code></pre></li></ul></li></ul><p>###16.06_集合框架(泛型概述和基本使用)(掌握)</p><ul><li>A:泛型概述</li><li>B:泛型好处<ul><li>提高安全性(将运行期的错误转换到编译期) </li><li>省去强转的麻烦</li></ul></li><li>C:泛型基本使用<ul><li>&lt;&gt;中放的必须是引用数据类型 </li></ul></li><li>D:泛型使用注意事项<ul><li>前后的泛型必须一致,或者后面的泛型可以省略不写(1.7的新特性菱形泛型)  </li></ul></li></ul><p>###16.07_集合框架(ArrayList存储字符串和自定义对象并遍历泛型版)(掌握)</p><ul><li>A:案例演示<ul><li>ArrayList存储字符串并遍历泛型版</li></ul></li></ul><p>###16.08_集合框架(泛型的由来)(了解)</p><ul><li>A:案例演示<ul><li>泛型的由来:通过Object转型问题引入</li><li>早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题。</li></ul></li></ul><p>###16.09_集合框架(泛型类的概述及使用)(了解)</p><ul><li>A:泛型类概述<t><ul><li>把泛型定义在类上</li></ul></t></li><li>B:定义格式<ul><li>public class 类名&lt;泛型类型1,…&gt;</li></ul></li><li>C:注意事项    <ul><li>泛型类型必须是引用类型</li></ul></li><li>D:案例演示<ul><li>泛型类的使用</li></ul></li></ul><p>###16.10_集合框架(泛型方法的概述和使用)(了解)</p><ul><li>A:泛型方法概述<ul><li>把泛型定义在方法上</li></ul></li><li>B:定义格式    <ul><li>public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 变量名)</li></ul></li><li>C:案例演示<ul><li>泛型方法的使用</li></ul></li></ul><p>###16.11_集合框架(泛型接口的概述和使用)(了解)</p><ul><li>A:泛型接口概述<ul><li>把泛型定义在接口上</li></ul></li><li>B:定义格式    <ul><li>public interface 接口名&lt;泛型类型&gt;</li></ul></li><li>C:案例演示<ul><li>泛型接口的使用</li></ul></li></ul><p>###16.12_集合框架(泛型高级之通配符)(了解)</p><ul><li>A:泛型通配符&lt;?&gt;<ul><li>任意类型，如果没有明确，那么就是Object以及任意的Java类了</li></ul></li><li>B:? extends E<ul><li>向下限定，E及其子类</li></ul></li><li><p>C:? super E</p><ul><li><p>向上限定，E及其父类</p><p>List&lt;?&gt; list = new ArrayList<integer>();            //当右边的泛型是不确定时,左边可以指定为?</integer></p></li></ul></li></ul><p>###16.13_集合框架(增强for的概述和使用)(掌握)</p><ul><li>A:增强for概述（底层是用Iterator迭代器实现的）<ul><li>简化数组和Collection集合的遍历</li></ul></li><li>B:格式：</li><li><pre><code>for(元素数据类型 变量 : 数组或者Collection集合) {    使用变量即可，该变量就是元素}</code></pre></li><li>C:案例演示<ul><li>数组，集合存储元素用增强for遍历</li></ul></li><li>D:好处<ul><li>简化遍历</li></ul></li></ul><p>###16.14_集合框架(ArrayList存储字符串和自定义对象并遍历增强for版)(掌握)</p><ul><li><p>A:案例演示</p><ul><li>ArrayList存储字符串并遍历增强for版</li><li><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;c&quot;);list.add(&quot;d&quot;);for(String s : list) {    System.out.println(s);}</code></pre><p>###16.15_集合框架(三种迭代的能否删除)(掌握)</p></li></ul></li><li>普通for循环,可以删除,但是索引要–  （因为删除数组中的一个元素后后面的元素会向上补齐）</li><li>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</li><li>增强for循环不能删除，（增强for的底层依赖的是Iterator迭代器，会发生并发修改异常）</li></ul><p>###16.16_集合框架(静态导入的概述和使用)(掌握)</p><ul><li>A:静态导入概述</li><li>B:格式：<ul><li>import static 包名….类名.方法名;</li><li>可以直接导入到方法的级别</li></ul></li><li>C:注意事项<ul><li>方法必须是静态的,如果有多个同名的静态方法，容易不知道使用谁?这个时候要使用，必须加前缀。由此可见，意义不大，所以一般不用，但是要能看懂。</li></ul></li></ul><p>###16.17_集合框架(可变参数的概述和使用)(掌握)</p><ul><li>A:可变参数概述<ul><li>定义方法的时候不知道该定义多少个参数</li></ul></li><li>B:格式<ul><li>修饰符 返回值类型 方法名(数据类型…  变量名){}</li></ul></li><li>C:注意事项：<ul><li>这里的变量其实是一个数组（可变参数其实是数组。长度可变）</li><li>如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个</li></ul></li></ul><p>###16.18_集合框架(Arrays工具类的asList()方法的使用)(掌握)</p><ul><li><p>A:案例演示</p><ul><li><p>Arrays工具类的asList()方法的使用<br>  *数组转换成集合</p><ul><li><p>数组转换成集合虽然不能增加或减少元素,但是可以用集合的思想操作数组,也就是说可以使用其他集合中的方法<br>List<string> list = Arrays.asList(arr);                //将数组转换成集合<br>list.add(“d”);                                        //不能添加</string></p><p>  <strong>基本数据类型的数组转换成集合,会将整个数组当作一个对象转换  </strong>将数组转换成集合,数组必须是引用数据类型</p><p>  <strong>当集合转换数组时,数组长度如果是小于等于集合的size时,转换后的数组长度等于集合的size  </strong>如果数组的长度大于了size,分配的数组长度就和你指定的长度一样</p></li></ul></li><li>Collection中toArray(T[] a)泛型版的集合转数组</li></ul></li></ul><p>###16.19_集合框架(集合嵌套之ArrayList嵌套ArrayList)(掌握)</p><ul><li>A:案例演示<ul><li>集合嵌套之ArrayList嵌套ArrayList</li></ul></li></ul><p>###16.20_day16总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###16.01_集合框架(去除ArrayList中重复字符串元素方式)(掌握)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A:案例演示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求：ArrayList去除集合中字符串的重复值(字符串的内容相同)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;思路：创建新集合方式&lt;/p
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ArrayList，泛型" scheme="http://zouyip.github.io/tags/ArrayList%EF%BC%8C%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>List</title>
    <link href="http://zouyip.github.io/2017/09/10/day15-List%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/10/day15-List笔记/</id>
    <published>2017-09-10T09:55:30.000Z</published>
    <updated>2017-10-25T01:47:41.283Z</updated>
    
    <content type="html"><![CDATA[<p>###15.01_集合框架(对象数组的概述和使用)</p><ul><li>A:案例演示<ul><li>需求：我有5个学生，请把这个5个学生的信息存储到数组中，并遍历数组，获取得到每一个学生信息。</li></ul></li><li><pre><code>Student[] arr = new Student[5];                    //存储学生对象arr[0] = new Student(&quot;张三&quot;, 23);arr[1] = new Student(&quot;李四&quot;, 24);arr[2] = new Student(&quot;王五&quot;, 25);arr[3] = new Student(&quot;赵六&quot;, 26);arr[4] = new Student(&quot;马哥&quot;, 20);for (int i = 0; i &lt; arr.length; i++) {    System.out.println(arr[i]);}</code></pre></li><li><p>B:画图演示</p><ul><li>把学生数组的案例画图讲解</li><li>数组和集合存储引用数据类型,存的都是地址值</li></ul></li></ul><p>###15.02_集合框架(集合的由来及集合继承体系图)</p><ul><li>A:集合的由来<ul><li>数组长度是固定,当添加的元素超过了数组的长度时需要对数组重新定义,太麻烦,java内部给我们提供了集合类,<br>能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少 </li></ul></li><li>B:数组和集合的区别<ul><li>区别1 : <ul><li>数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值</li><li>集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象</li></ul></li><li>区别2:<ul><li>数组长度是固定的,不能自动增长</li><li>集合的长度的是可变的,可以根据元素的增加而增长</li></ul></li></ul></li><li>C:数组和集合什么时候用<pre><code>* 1,如果元素个数是固定的推荐用数组* 2,如果元素个数不是固定的推荐用集合</code></pre></li><li>D:集合继承体系图</li></ul><p>###15.03_集合框架(Collection集合的基本功能测试)</p><ul><li>A:案例演示    </li><li><pre><code>基本功能演示boolean add(E e)boolean remove(Object o)void clear()boolean contains(Object o)boolean isEmpty()int size()</code></pre></li><li><p>B:注意:</p></li><li><pre><code>collectionXxx.java使用了未经检查或不安全的操作.注意:要了解详细信息,请使用 -Xlint:unchecked重新编译.java编译器认为该程序存在安全隐患温馨提示:这不是编译失败,所以先不用理会,等学了泛型你就知道了</code></pre></li></ul><p>###15.04_集合框架(集合的遍历之集合转数组遍历)</p><ul><li>A:集合的遍历<ul><li>其实就是依次获取集合中的每一个元素。</li></ul></li><li><p>B:案例演示</p><ul><li>把集合转成数组，可以实现集合的遍历</li><li><p>toArray()<br>*</p><pre><code>Collection coll = new ArrayList();coll.add(new Student(&quot;张三&quot;,23));        //Object obj = new Student(&quot;张三&quot;,23);coll.add(new Student(&quot;李四&quot;,24));coll.add(new Student(&quot;王五&quot;,25));coll.add(new Student(&quot;赵六&quot;,26));Object[] arr = coll.toArray();                //将集合转换成数组for (int i = 0; i &lt; arr.length; i++) {    Student s = (Student)arr[i];            //强转成Student    System.out.println(s.getName() + &quot;,&quot; + s.getAge());}</code></pre></li></ul></li></ul><p>###15.05_集合框架(Collection集合的带All功能测试)</p><ul><li>A:案例演示</li><li><pre><code>带All的功能演示boolean addAll(Collection c)        c1.addAll(c2);                //将c2中的每一个元素添加到c1中    c1.add(c2);                    //将c2看成一个对象添加到c1中boolean removeAll(Collection c)        删除的是交集boolean containsAll(Collection c)    判断调用的集合是否包含传入的集合boolean retainAll(Collection c)        取交集,如果调用的集合改变就返回true,如果调用的集合不变就返回false</code></pre></li></ul><p>###15.06_集合框架(集合的遍历之迭代器遍历)</p><ul><li>A:迭代器概述<ul><li>集合是用来存储元素,存储的元素需要查看,那么就需要迭代(遍历) </li></ul></li><li><p>B:案例演示</p><ul><li><p>迭代器的使用</p><pre><code>Collection c = new ArrayList();c.add(&quot;a&quot;);c.add(&quot;b&quot;);c.add(&quot;c&quot;);c.add(&quot;d&quot;);Iterator it = c.iterator();                        //获取迭代器的引用while(it.hasNext()) {                            //集合中的迭代方法(遍历)    System.out.println(it.next());}</code></pre></li></ul></li></ul><p>###15.07_集合框架(Collection存储自定义对象并遍历)</p><ul><li><p>A:案例演示</p><ul><li>Collection存储自定义对象并用迭代器遍历</li><li><pre><code>Collection c = new ArrayList();c.add(new Student(&quot;张三&quot;,23));c.add(new Student(&quot;李四&quot;,24));c.add(new Student(&quot;王五&quot;,25));c.add(new Student(&quot;赵六&quot;,26));c.add(new Student(&quot;赵六&quot;,26));for(Iterator it = c.iterator();it.hasNext();) {    Student s = (Student)it.next();                        //向下转型    System.out.println(s.getName() + &quot;,&quot; + s.getAge());    //获取对象中的姓名和年龄}System.out.println(&quot;------------------------------&quot;);Iterator it = c.iterator();                                //获取迭代器while(it.hasNext()) {                                    //判断集合中是否有元素    //System.out.println(((Student)(it.next())).getName() + &quot;,&quot; + ((Student)(it.next())).getAge());    Student s = (Student)it.next();                        //向下转型    System.out.println(s.getName() + &quot;,&quot; + s.getAge());    //获取对象中的姓名和年龄}</code></pre></li></ul></li></ul><p>###15.08_集合框架(迭代器的原理及源码解析)(了解)</p><ul><li>A:迭代器原理<ul><li>迭代器原理:迭代器是对集合进行遍历,而每一个集合内部的存储结构都是不同的,所以每一个集合存和取都是不一样,<br>那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,<br>迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式（覆写了）,这样做的好处有二,<br>第一规定了整个集合体系的遍历方式都是hasNext()和next()方法,第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可 </li></ul></li><li>B:迭代器源码解析<ul><li>1,在eclipse中ctrl + shift + t找到ArrayList类</li><li>2,ctrl+o查找iterator()方法</li><li>3,查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口</li><li>4,查找Itr这个内部类,发现重写了Iterator中的所有抽象方法 </li></ul></li></ul><p>###15.09_集合框架(List集合的特有功能概述和测试)                List(数据结构：有序,可重复)</p><ul><li>A:List集合的特有功能概述<ul><li>void add(int index,E element)        通过索引增加元素（若无索引参数，则自动在后面增加）</li><li>E remove(int index)        通过索引删除元素,将被删除的元素返回</li><li>E get(int index)</li><li>E set(int index,E element)</li></ul></li></ul><p>###15.10_集合框架(List集合存储学生对象并遍历)</p><ul><li><p>A:案例演示</p><ul><li><p>通过size()和get()方法结合使用遍历。</p><pre><code>List list = new ArrayList();list.add(new Student(&quot;张三&quot;, 18));list.add(new Student(&quot;李四&quot;, 18));list.add(new Student(&quot;王五&quot;, 18));list.add(new Student(&quot;赵六&quot;, 18));for(int i = 0; i &lt; list.size(); i++) {    Student s = (Student)list.get(i);    System.out.println(s.getName() + &quot;,&quot; + s.getAge());}</code></pre></li></ul></li></ul><p>###15.11_集合框架(并发修改异常产生的原因及解决方案)</p><ul><li><p>A:案例演示</p><ul><li><p>需求：我有一个集合，请问，我想判断里面有没有”world”这个元素，如果有，我就添加一个”javaee”元素，请写代码实现。</p><pre><code>List list = new ArrayList();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;world&quot;);list.add(&quot;d&quot;);list.add(&quot;e&quot;);/*Iterator it = list.iterator();while(it.hasNext()) {    String str = (String)it.next();    if(str.equals(&quot;world&quot;)) {        list.add(&quot;javaee&quot;);            //这里会抛出ConcurrentModificationException并发修改异常    }}*/</code></pre></li></ul></li></ul><ul><li>B:ConcurrentModificationException出现<ul><li>迭代器遍历，集合修改集合</li></ul></li><li><p>C:解决方案</p><ul><li>a:迭代器迭代元素，迭代器修改元素(ListIterator的特有功能add)</li><li><p>b:集合遍历元素，集合修改元素</p><pre><code>ListIterator lit = list.listIterator();        //如果想在遍历的过程中添加元素,可以用ListIterator中的add方法while(lit.hasNext()) {    String str = (String)lit.next();    if(str.equals(&quot;world&quot;)) {        lit.add(&quot;javaee&quot;);            //list.add(&quot;javaee&quot;);    }}</code></pre></li></ul></li></ul><p>###15.12_集合框架(ListIterator)(了解)</p><ul><li>boolean hasNext()是否有下一个</li><li>boolean hasPrevious()是否有前一个</li><li>Object next()返回下一个元素， 获取元素并将指针向后移动</li><li>Object previous();返回上一个元素，获取元素并将指针向前移动</li></ul><p>###15.13_集合框架(Vector的特有功能)</p><ul><li>A:Vector类概述</li><li>B:Vector类特有功能<ul><li>public void addElement(E obj)</li><li>public E elementAt(int index)</li><li>public Enumeration elements()</li></ul></li><li><p>C:案例演示    </p><ul><li><p>Vector的迭代（Vector是用枚举Enumeration迭代）</p><pre><code>Vector v = new Vector();                //创建集合对象,List的子类v.addElement(&quot;a&quot;);v.addElement(&quot;b&quot;);v.addElement(&quot;c&quot;);v.addElement(&quot;d&quot;);//Vector迭代Enumeration en = v.elements();            //获取枚举while(en.hasMoreElements()) {            //判断集合中是否有元素    System.out.println(en.nextElement());//获取集合中的元素}</code></pre></li></ul></li></ul><p>###15.14_集合框架(数据结构之数组和链表：链表增删快，改查慢。数组则相反)</p><ul><li>A:数组<ul><li>查询快修改也快</li><li>增删慢</li></ul></li><li>B:链表<ul><li>查询慢,修改也慢</li><li>增删快</li></ul></li></ul><p>###15.15_集合框架(List的三个子类的特点)</p><ul><li>A:List的三个子类的特点</li><li><pre><code>ArrayList:    底层数据结构是数组，查询快，增删慢。    线程不安全，效率高。线程不同步Vector:    底层数据结构是数组，查询快，增删慢。    线程安全，效率低。Vector相对ArrayList查询慢(线程安全的)Vector相对LinkedList（链表结构）增删慢(数组结构)LinkedList:    底层数据结构是链表，查询慢，增删快。    线程不安全，效率高。Vector和ArrayList的区别    Vector是线程安全的,效率低    ArrayList是线程不安全的,效率高。线程同步共同点:都是数组实现的ArrayList和LinkedList的区别    ArrayList底层是数组结果,查询和修改快    LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢共同点:都是线程不安全的</code></pre></li><li>B:List有三个儿子，我们到底使用谁呢?<pre><code>查询多用ArrayList增删多用LinkedList如果都多ArrayList（Vector已经被ArrayList完全取代了，如果要求线程安全可以使用工具类，将ArrayList变为线程安全的，                    所以Vector已经几乎不再使用了）</code></pre>###15.16_day15总结<br>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###15.01_集合框架(对象数组的概述和使用)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:案例演示&lt;ul&gt;
&lt;li&gt;需求：我有5个学生，请把这个5个学生的信息存储到数组中，并遍历数组，获取得到每一个学生信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;Stud
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="List" scheme="http://zouyip.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式与Date类</title>
    <link href="http://zouyip.github.io/2017/09/07/day14-Date%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/07/day14-Date笔记/</id>
    <published>2017-09-07T10:55:30.000Z</published>
    <updated>2017-10-25T01:46:31.710Z</updated>
    
    <content type="html"><![CDATA[<p>###14.01_常见对象(正则表达式的概述和简单使用)</p><ul><li>A:正则表达式<ul><li>是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。</li><li>作用:比如注册邮箱,邮箱有用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的</li></ul></li><li><p>B:案例演示</p><ul><li><p>需求：校验qq号码.</p><ul><li>1:要求必须是5-15位数字</li><li>2:0不能开头</li><li>3:必须都是数字</li></ul></li><li><p>a:非正则表达式实现</p></li><li>b:正则表达式实现</li></ul></li></ul><p>###14.02_常见对象(字符类演示)</p><ul><li>A:字符类<ul><li>[abc] a、b 或 c（简单类） </li><li>[^abc] 任何字符，除了 a、b 或 c（否定） </li><li>[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） </li><li>[0-9] 0到9的字符都包括<br>###14.03_常见对象(预定义字符类演示)</li></ul></li><li>A:预定义字符类<ul><li>. 任何字符。</li><li>\d 数字：[0-9]</li><li>\w 单词字符：[a-zA-Z<em>0-9]<br>###14.04</em>常见对象(数量词)</li></ul></li><li>A:Greedy 数量词 <ul><li>X? X，一次或一次也没有</li><li>X* X，零次或多次</li><li>X+ X，一次或多次</li><li>X{n} X，恰好 n 次 </li><li>X{n,} X，至少 n 次 </li><li>X{n,m} X，至少 n 次，但是不超过 m 次 </li></ul></li></ul><p>###14.05_常见对象(正则表达式的分割功能)</p><ul><li>A:正则表达式的分割功能<ul><li>String类的功能：public String[] split(String regex)</li></ul></li><li>B:案例演示<ul><li>正则表达式的分割功能</li></ul></li></ul><p>###14.06_常见对象(把给定字符串中的数字排序)</p><ul><li>A:案例演示<ul><li>需求：我有如下一个字符串:”91 27 46 38 50”，请写代码实现最终输出结果是：”27 38 46 50 91”</li><li>分析:<ul><li>1,将字符串切割成字符串数组        public String[] split(String regex) 返回值是字符串数组</li><li>2,将字符串转换成数字并将其存储在一个等长度的int数组中</li><li>3,排序</li><li>4,将排序后的结果遍历并拼接成一个字符串</li></ul></li></ul></li></ul><p>###14.07_常见对象(正则表达式的替换功能)</p><ul><li>A:正则表达式的替换功能<ul><li>String类的功能：public String replaceAll(String regex,String replacement)</li></ul></li><li>B:案例演示<ul><li>正则表达式的替换功能</li></ul></li></ul><p>###14.08_常见对象(正则表达式的分组功能)</p><ul><li>A:正则表达式的分组功能<ul><li>捕获组可以通过从左到右计算其开括号来编号。例如，在表达式 ((A)(B(C))) 中，存在四个这样的组： </li></ul></li><li><pre><code>1     ((A)(B(C))) 2     (A 3     (B(C)) 4     (C) 组零始终代表整个表达式。</code></pre><p>B:案例演示<br>  a:切割</p><pre><code>需求：请按照叠词切割： &quot;sdqqfgkkkhjppppkl&quot;;</code></pre><p>  b:替换</p><pre><code>需求：我我....我...我.要...要要...要学....学学..学.编..编编.编.程.程.程..程将字符串还原成:“我要学编程”。</code></pre><p>###14.09_常见对象(Pattern和Matcher的概述)</p></li><li>A:Pattern和Matcher的概述</li><li><p>B:模式和匹配器的典型调用顺序</p><ul><li><p>通过JDK提供的API，查看Pattern类的说明</p></li><li><p>典型的调用顺序是 </p></li><li>Pattern p = Pattern.compile(“a*b”);</li><li>Matcher m = p.matcher(“aaaaab”);</li><li>boolean b = m.matches();</li></ul></li></ul><p>###14.10_常见对象(正则表达式的获取功能)</p><ul><li>A:正则表达式的获取功能<ul><li>Pattern和Matcher的结合使用</li></ul></li><li>B:案例演示<ul><li>需求：把一个字符串中的手机号码获取出来</li></ul></li></ul><p>###14.11_常见对象(Math类概述和方法使用)</p><ul><li>A:Math类概述<ul><li>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 </li></ul></li><li>B:成员方法<ul><li>public static int abs(int a)</li><li>public static double ceil(double a)</li><li>public static double floor(double a)</li><li>public static int max(int a,int b) min自学</li><li>public static double pow(double a,double b)</li><li>public static double random()</li><li>public static int round(float a) 参数为double的自学</li><li>public static double sqrt(double a)</li></ul></li></ul><p>###14.12_常见对象(Random类的概述和方法使用)</p><ul><li>A:Random类的概述<ul><li>此类用于产生随机数如果用相同的种子创建两个 Random 实例，</li><li>则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列。</li></ul></li><li>B:构造方法<br>  <em>Random() ：创建一个新的随机数发生器。  </em>Random(long seed) ：用一个种子（长整型）创建一个随机数发生器。</li><li>C:成员方法：nextInt(int n) 方法用于获取一个伪随机，在0(包括)和指定值(不包括)，<pre><code>从此随机数生成器的序列中取出均匀分布的int值。</code></pre><ul><li>public int nextInt()</li><li>public int nextInt(int n)(重点掌握)</li></ul></li></ul><p>###14.13_常见对象(System类的概述和方法使用)</p><ul><li>A:System类的概述<ul><li>System 类包含一些有用的类字段和方法。它不能被实例化。 </li></ul></li><li>B:成员方法<ul><li>public static void gc()</li><li>public static void exit(int status)</li><li>public static long currentTimeMillis()</li><li>pubiic static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) </li></ul></li><li>C:案例演示<ul><li>System类的成员方法使用</li></ul></li></ul><p>###14.14_常见对象(BigInteger类的概述和方法使用)</p><ul><li>A:BigInteger的概述<ul><li>可以让超过Integer范围内的数据进行运算</li></ul></li><li>B:构造方法<ul><li>public BigInteger(String val)</li></ul></li><li>C:成员方法<ul><li>public BigInteger add(BigInteger val)</li><li>public BigInteger subtract(BigInteger val)</li><li>public BigInteger multiply(BigInteger val)</li><li>public BigInteger divide(BigInteger val)</li><li>public BigInteger[] divideAndRemainder(BigInteger val)</li></ul></li></ul><p>###14.15_常见对象(BigDecimal类的概述和方法使用)</p><ul><li><p>A:BigDecimal的概述</p><ul><li>由于在运算的时候，float类型和double很容易丢失精度，演示案例。</li><li><p>所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal</p></li><li><p>不可变的、任意精度的有符号十进制数。</p></li></ul></li><li>B:构造方法<ul><li>public BigDecimal(String val)</li></ul></li><li>C:成员方法<ul><li>public BigDecimal add(BigDecimal augend)</li><li>public BigDecimal subtract(BigDecimal subtrahend)</li><li>public BigDecimal multiply(BigDecimal multiplicand)</li><li>public BigDecimal divide(BigDecimal divisor)</li></ul></li><li>D:案例演示<ul><li>BigDecimal类的构造方法和成员方法使用</li></ul></li></ul><p>###14.16_常见对象(Date类的概述和方法使用)(掌握)</p><ul><li>A:Date类的概述<ul><li>类 Date 表示特定的瞬间，精确到毫秒。 </li></ul></li><li>B:构造方法<ul><li>public Date()</li><li>public Date(long date)</li></ul></li><li>C:成员方法<ul><li>public long getTime()</li><li>public void setTime(long time)</li></ul></li></ul><p>###14.17_常见对象(SimpleDateFormat类实现日期和字符串的相互转换)(掌握)</p><ul><li>A:DateFormat类的概述<ul><li>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。是抽象类，所以使用其子类SimpleDateFormat</li></ul></li><li>B:SimpleDateFormat构造方法<ul><li>public SimpleDateFormat()</li><li>public SimpleDateFormat(String pattern)</li></ul></li><li>C:成员方法<ul><li>public final String format(Date date)</li><li>public Date parse(String source)</li></ul></li></ul><p>###14.18_常见对象(你来到这个世界多少天案例)(掌握)</p><ul><li>A:案例演示<ul><li>需求：算一下你来到这个世界多少天?</li></ul></li></ul><p>###14.19_常见对象(Calendar类的概述和获取日期的方法)(掌握)</p><ul><li>A:Calendar类的概述<ul><li>Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</li></ul></li><li>B:成员方法<ul><li>public static Calendar getInstance()</li><li>public int get(int field)</li></ul></li></ul><p>###14.20_常见对象(Calendar类的add()和set()方法)(掌握)</p><ul><li>A:成员方法<ul><li>public void add(int field,int amount)</li><li>public final void set(int year,int month,int date)</li></ul></li><li>B:案例演示<ul><li>Calendar类的成员方法使用</li></ul></li></ul><p>###14.21_常见对象(如何获取任意年份是平年还是闰年)(掌握)</p><ul><li>A:案例演示<ul><li>需求：键盘录入任意一个年份，判断该年是闰年还是平年</li></ul></li></ul><p>###14.22_day14总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###14.01_常见对象(正则表达式的概述和简单使用)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:正则表达式&lt;ul&gt;
&lt;li&gt;是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。&lt;/li&gt;
&lt;li&gt;作用:比如注册邮箱,邮箱有用户名和
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="正则，Date类" scheme="http://zouyip.github.io/tags/%E6%AD%A3%E5%88%99%EF%BC%8CDate%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>StringBuffer类</title>
    <link href="http://zouyip.github.io/2017/09/07/day13-StringBuffer%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/07/day13-StringBuffer笔记/</id>
    <published>2017-09-07T03:50:30.000Z</published>
    <updated>2017-10-25T01:37:24.518Z</updated>
    
    <content type="html"><![CDATA[<p>###13.01_常见对象(StringBuffer类的概述)</p><ul><li>A:StringBuffer类概述<ul><li>通过JDK提供的API，查看StringBuffer类的说明</li><li>线程安全的可变字符序列 </li></ul></li><li>B:StringBuffer和String的区别<ul><li>String是一个不可变的字符序列</li><li>StringBuffer是一个可变的字符序列 </li></ul></li></ul><p>###13.02_常见对象(StringBuffer类的构造方法)</p><ul><li>A:StringBuffer的构造方法：<ul><li>public StringBuffer():无参构造方法</li><li>public StringBuffer(int capacity):指定容量的字符串缓冲区对象</li><li>public StringBuffer(String str):指定字符串内容的字符串缓冲区对象</li></ul></li><li>B:StringBuffer的方法：<ul><li>public int capacity()：返回当前容量。    理论值(不掌握)</li><li>public int length():返回长度（字符数）。 实际值</li></ul></li><li>C:案例演示<ul><li>构造方法和长度方法的使用</li></ul></li></ul><p>###13.03_常见对象(StringBuffer的添加功能)</p><ul><li><p>A:StringBuffer的添加功能</p><ul><li>public StringBuffer append(String str):<ul><li>可以把任意类型数据添加到字符串缓冲区里面,并返回字符串缓冲区本身</li></ul></li><li><p>public StringBuffer insert(int offset,String str):</p><ul><li>在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身</li></ul><p>StringBuffer是字符串缓冲区,当new的时候是在堆内存创建了一个对象,底层是一个长度为16的字符数组<br>  当调用添加的方法时,不会再重新创建对象,在不断向原缓冲区添加字符</p></li></ul></li></ul><p>###13.04_常见对象(StringBuffer的删除功能)</p><ul><li>A:StringBuffer的删除功能<ul><li>public StringBuffer deleteCharAt(int index):<ul><li>删除指定位置的字符，并返回本身</li></ul></li><li>public StringBuffer delete(int start,int end):<ul><li>删除从指定位置开始指定位置结束的内容，并返回本身</li></ul></li></ul></li></ul><p>###13.05_常见对象(StringBuffer的替换和反转功能)</p><ul><li>A:StringBuffer的替换功能<ul><li>public StringBuffer replace(int start,int end,String str):<ul><li>从start开始到end用str替换</li></ul></li></ul></li><li>B:StringBuffer的反转功能<ul><li>public StringBuffer reverse():<ul><li>字符串反转</li></ul></li></ul></li></ul><p>###13.06_常见对象(StringBuffer的截取功能及注意事项)</p><ul><li>A:StringBuffer的截取功能<ul><li>public String substring(int start):<ul><li>从指定位置截取到末尾</li></ul></li><li>public String substring(int start,int end):<ul><li>截取从指定位置开始到结束位置，包括开始位置，不包括结束位置</li></ul></li></ul></li><li>B:注意事项<ul><li>注意:返回值类型不再是StringBuffer本身</li></ul></li></ul><p>###13.07_常见对象(StringBuffer和String的相互转换)</p><ul><li>A:String – StringBuffer<ul><li>a:通过构造方法</li><li>b:通过append()方法</li></ul></li><li>B:StringBuffer – String<ul><li>a:通过构造方法</li><li>b:通过toString()方法</li><li>c:通过subString(0,length);</li></ul></li></ul><p>###13.08_常见对象(把数组转成字符串)</p><ul><li><p>A:案例演示</p><ul><li>需求：把数组中的数据按照指定个格式拼接成一个字符串</li><li><pre><code>举例：    int[] arr = {1,2,3};    输出结果：    &quot;[1, 2, 3]&quot;用StringBuffer的功能实现</code></pre></li></ul></li></ul><p>###13.09_常见对象(字符串反转)</p><ul><li>A:案例演示</li><li><pre><code>需求：把字符串反转    举例：键盘录入&quot;abc&quot;            输出结果：&quot;cba&quot;用StringBuffer的功能实现    </code></pre></li></ul><p>###13.10_常见对象(StringBuffer和StringBuilder的区别)</p><ul><li>A:StringBuilder的概述<ul><li>通过查看API了解一下StringBuilder类</li></ul></li><li><p>B:面试题</p><ul><li>String,StringBuffer,StringBuilder的区别</li><li>StringBuffer和StringBuilder的区别</li><li>StringBuffer是jdk1.0版本的,是线程安全的,效率低</li><li><p>StringBuilder是jdk1.5版本的,是线程不安全的,效率高</p></li><li><p>String和StringBuffer,StringBuilder的区别</p></li><li>String是一个不可变的字符序列</li><li>StringBuffer,StringBuilder是可变的字符序列</li></ul></li></ul><p>###13.11_常见对象(String和StringBuffer分别作为参数传递)</p><ul><li>A:形式参数问题<ul><li>String作为参数传递</li><li>StringBuffer作为参数传递 </li></ul></li><li>B:案例演示<ul><li>String和StringBuffer分别作为参数传递问题</li></ul></li></ul><p>###13.12_常见对象(数组高级冒泡排序原理图解)</p><ul><li>A:画图演示</li><li><pre><code>需求：    数组元素：{24, 69, 80, 57, 13}    请对数组元素进行排序。    冒泡排序        相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处</code></pre></li></ul><p>###13.13_常见对象(数组高级冒泡排序代码实现)</p><ul><li>A:案例演示<ul><li>数组高级冒泡排序代码</li></ul></li></ul><p>###13.14_常见对象(数组高级选择排序原理图解)</p><ul><li><p>A:画图演示</p><ul><li><p>需求：</p><ul><li>数组元素：{24, 69, 80, 57, 13}</li><li><p>请对数组元素进行排序。</p></li><li><p>选择排序</p><ul><li>从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处</li></ul></li></ul></li></ul></li></ul><p>###13.15_常见对象(数组高级选择排序代码实现)</p><ul><li>A:案例演示<ul><li>数组高级选择排序代码</li></ul></li></ul><p>###13.16_常见对象(数组高级二分查找原理图解)</p><ul><li>A:画图演示<ul><li>二分查找  </li><li>前提：数组元素有序</li></ul></li></ul><p>###13.17_常见对象(数组高级二分查找代码实现及注意事项)</p><ul><li>A:案例演示<ul><li>数组高级二分查找代码</li></ul></li><li>B:注意事项<ul><li>如果数组无序，就不能使用二分查找。<ul><li>因为如果你排序了，但是你排序的时候已经改变了我最原始的元素索引。</li></ul></li></ul></li></ul><p>####总结：循环嵌套的排序算法中外层循环控制的是比较的次数。</p><p>###13.18_常见对象(Arrays类的概述和方法使用)</p><ul><li>A:Arrays类概述<ul><li>针对数组进行操作的工具类。</li><li>提供了排序，查找等功能。</li></ul></li><li>B:成员方法<ul><li>public static String toString(int[] a)</li><li>public static void sort(int[] a)</li><li>public static int binarySearch(int[] a,int key)</li></ul></li></ul><p>###13.19_常见对象(基本类型包装类的概述)</p><ul><li>A:为什么会有基本类型包装类<ul><li>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。</li></ul></li><li>B:常用操作<ul><li>常用的操作之一：用于基本数据类型与字符串之间的转换。</li></ul></li><li>C:基本类型和包装类的对应</li><li><pre><code>byte             Byteshort            Shortint                Integerlong            Longfloat            Floatdouble            Doublechar            Characterboolean            Boolean</code></pre></li></ul><p>###13.20_常见对象(Integer类的概述和构造方法)</p><ul><li><p>A:Integer类概述</p><ul><li><p>通过JDK提供的API，查看Integer类的说明</p></li><li><p>Integer 类在对象中包装了一个基本类型 int 的值,</p></li><li>该类提供了多个方法，能在 int 类型和 String 类型之间互相转换，</li><li>还提供了处理 int 类型时非常有用的其他一些常量和方法</li></ul></li><li>B:构造方法<ul><li>public Integer(int value)</li><li>public Integer(String s)<br>  //Integer i2 = new Integer(“abc”);            //java.lang.NumberFormatException数字格式异常<br>  //System.out.println(i2);                    //因为abc不是数字字符串,所以转换会报错</li></ul></li><li>C:案例演示<ul><li>使用构造方法创建对象</li></ul></li></ul><p>###13.21_常见对象(String和int类型的相互转换)</p><ul><li>A:int – String<ul><li>a:和””进行拼接</li><li>b:public static String valueOf(int i)</li><li>c:int – Integer – String(Integer类的toString方法())</li><li>d:public static String toString(int i)(Integer类的静态方法)</li></ul></li><li>B:String – int<ul><li>a:String – Integer – int</li><li>public static int parseInt(String s)</li></ul></li></ul><p>###13.22_常见对象(JDK5的新特性自动装箱和拆箱)</p><ul><li>A:JDK5的新特性<ul><li>自动装箱：把基本类型转换为包装类类型</li><li>自动拆箱：把包装类类型转换为基本类型</li></ul></li><li><p>B:案例演示</p><ul><li><p>JDK5的新特性自动装箱和拆箱</p></li><li><p>Integer ii = 100;</p></li><li>ii += 200;</li></ul></li><li>C:注意事项<ul><li>在使用时，Integer  x = null;代码就会出现NullPointerException。</li><li>建议先判断是否为null，然后再使用。</li></ul></li></ul><p>###13.23_常见对象(Integer的面试题)</p><ul><li>A:Integer的面试题</li><li><pre><code>看程序写结果Integer i1 = new Integer(97);Integer i2 = new Integer(97);System.out.println(i1 == i2);        //falseSystem.out.println(i1.equals(i2));    //trueSystem.out.println(&quot;-----------&quot;);Integer i3 = new Integer(197);Integer i4 = new Integer(197);System.out.println(i3 == i4);        //falseSystem.out.println(i3.equals(i4));    //trueSystem.out.println(&quot;-----------&quot;);Integer i5 = 97;Integer i6 = 97;System.out.println(i5 == i6);        //trueSystem.out.println(i5.equals(i6));    //true System.out.println(&quot;-----------&quot;);Integer i7 = 197;Integer i8 = 197;System.out.println(i7 == i8);        //falseSystem.out.println(i7.equals(i8));    //true    </code></pre></li><li><p>-128到127是byte的取值范围,如果在这个取值范围内,自动装箱就不会新创建对象,而是从常量池中获取</p><pre><code>* 如果超过了byte取值范围就会再新创建对象* * public static Integer valueOf(int i) {       assert IntegerCache.high &gt;= 127;       if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)            //i&gt;= -128 &amp;&amp; i &lt;= 127           return IntegerCache.cache[i + (-IntegerCache.low)];       return new Integer(i);   }*/</code></pre><p>  }</p></li></ul><p>}</p><p>###13.24_day13总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###13.01_常见对象(StringBuffer类的概述)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:StringBuffer类概述&lt;ul&gt;
&lt;li&gt;通过JDK提供的API，查看StringBuffer类的说明&lt;/li&gt;
&lt;li&gt;线程安全的可变字符序列 &lt;/li&gt;
&lt;/ul&gt;
&lt;/
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="StringBuffer" scheme="http://zouyip.github.io/tags/StringBuffer/"/>
    
  </entry>
  
  <entry>
    <title>String类概述</title>
    <link href="http://zouyip.github.io/2017/09/06/day12-String%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/06/day12-String笔记/</id>
    <published>2017-09-06T04:50:33.000Z</published>
    <updated>2017-10-25T01:38:17.942Z</updated>
    
    <content type="html"><![CDATA[<p>###12.01_常见对象(Scanner的概述和方法介绍)(掌握)</p><ul><li>A:Scanner的概述</li><li><p>B:Scanner的构造方法原理</p><ul><li>Scanner(InputStream source)</li><li>System类下有一个静态的字段：<ul><li>public static final InputStream in; 标准的输入流，对应着键盘录入。</li></ul></li></ul></li><li><p>C:一般方法</p><ul><li>hasNextXxx()  判断是否还有下一个输入项,其中Xxx可以是Int,Double等。如果需要判断是否包含下一个字符串，则可以省略Xxx</li><li>nextXxx()  获取下一个输入项。Xxx的含义和上个方法中的Xxx相同,默认情况下，Scanner使用空格，回车等作为分隔符</li></ul></li></ul><p>###12.02_常见对象(Scanner获取数据出现的小问题及解决方案)(掌握)</p><ul><li>A:两个常用的方法：<ul><li>public int nextInt():获取一个int类型的值</li><li>public String nextLine():获取一个String类型的值</li></ul></li><li>B:案例演示<ul><li>a:先演示获取多个int值，多个String值的情况</li><li>b:再演示先获取int值，然后获取String值出现问题</li><li>c:问题解决方案<ul><li>第一种：先获取一个数值后，再创建一个新的键盘录入对象获取字符串。</li><li>第二种：把所有的数据都先按照字符串获取，然后要什么，你就对应的转换为什么。(后面讲)</li></ul></li></ul></li></ul><p>###12.03_常见对象(String类的概述)(掌握)</p><ul><li><p>A:String类的概述    </p><ul><li><p>通过JDK提供的API，查看String类的说明</p></li><li><p>可以看到这样的两句话。</p><ul><li>a:字符串字面值”abc”也可以看成是一个字符串对象。</li><li>b:字符串是常量，一旦被赋值，就不能被改变。<br>String str = “abc”;                    //“abc”可以看成一个字符串对象<br>str = “def”;                        //当把”def”赋值给str,原来的”abc”就变成了垃圾<br>System.out.println(str);        //输出def，但是并不是改变了“abc”，而是重新创建了一个对象“def”并将地址值赋给了str</li></ul></li></ul></li></ul><p>###12.04_常见对象(String类的构造方法)(掌握)</p><ul><li>A:常见构造方法<ul><li>public String():空构造</li><li>public String(byte[] bytes):把字节数组转成字符串</li><li>public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串</li><li>public String(char[] value):把字符数组转成字符串</li><li>public String(char[] value,int index,int count):把字符数组的一部分转成字符串</li><li>public String(String original):把字符串常量值转成字符串</li></ul></li><li>B:案例演示    <ul><li>演示String类的常见构造方法</li></ul></li></ul><p>###12.05_常见对象(String类的常见面试题)(掌握)</p><ul><li>1.判断定义为String类型的s1和s2是否相等<ul><li>String s1 = “abc”;            //常量池中没有这个字符串对象,就创建一个,如果有直接用即可</li><li>String s2 = “abc”;</li><li>System.out.println(s1 == s2);         –true            </li><li>System.out.println(s1.equals(s2));     –true</li></ul></li><li>2.下面这句话在内存中创建了几个对象?<br>  //创建两个对象,一个在常量池中,一个在堆内存中<ul><li>String s1 = new String(“abc”);    –创建了两个对象，记录的是堆内存对象的地址值<pre><code>（在常量池中也会创建一个对象，堆中也会创建一个对象）堆中的对象相当于是常量池中的副本    </code></pre></li></ul></li><li>3.判断定义为String类型的s1和s2是否相等<ul><li>String s1 = new String(“abc”);        //记录的是堆内存对象的地址值        </li><li>String s2 = “abc”;                    //记录的是常量池中的地址值</li><li>System.out.println(s1 == s2); ?        –false</li><li>System.out.println(s1.equals(s2)); ?    –true</li></ul></li><li>4.判断定义为String类型的s1和s2是否相等<ul><li>String s1 = “a” + “b” + “c”;</li><li>String s2 = “abc”;</li><li>System.out.println(s1 == s2); ?            //true,java中有常量优化机制</li><li>System.out.println(s1.equals(s2)); ?        //true</li></ul></li><li>5.判断定义为String类型的s1和s2是否相等<ul><li>String s1 = “ab”;</li><li>String s2 = “abc”;</li><li>String s3 = s1 + “c”;</li><li>System.out.println(s3 == s2);                –false</li><li>System.out.println(s3.equals(s2)); ?        –true    </li></ul></li></ul><p>java语言提供对字符串串联符号（“+”）以及将其他对象转换为字符串的特殊支持。字符串串联是通过StringBuilder（或StringBuffer）<br>及其append方法实现的。字符串转换是通过toString方法是实现的。<br>    字符串常量直接赋值给String类声明的变量，则从常量池中寻找该字符串常量赋值给该变量，若常量池中没有创建该字符串常量则<br>    在常量池中创建该字符串常量然后赋值给该String变量<br>    eg：* String s1 = “abc”;</p><pre><code>    * String s2 = &quot;abc&quot;;    * System.out.println(s1 == s2);                         * System.out.println(s1.equals(s2));     其中s1与s2指向的是常量池中同一个常量，地址值相同。###12.06_常见对象(String类的判断功能)(掌握)</code></pre><ul><li>A:String类的判断功能<ul><li>boolean equals(Object obj):比较字符串的内容是否相同,区分大小写</li><li>boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</li><li>boolean contains(String str):判断大字符串中是否包含小字符串</li><li>boolean startsWith(String str):判断字符串是否以某个指定的字符串开头</li><li>boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾</li><li>boolean isEmpty():判断字符串是否为空。</li></ul></li></ul><p>###12.07_常见对象(模拟用户登录)(掌握)</p><ul><li>A:案例演示<ul><li>需求：模拟登录,给三次机会,并提示还有几次。</li><li>用户名和密码都是admin</li></ul></li></ul><p>###12.08_常见对象(String类的获取功能)(掌握)</p><ul><li>A:String类的获取功能<ul><li>int length():获取字符串的长度。</li><li>char charAt(int index):获取指定索引位置的字符</li><li>int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。</li><li>int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。</li><li>int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。</li><li>int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。</li><li>lastIndexOf</li><li>String substring(int start):从指定位置开始截取字符串,默认到末尾。</li><li>String substring(int start,int end):从指定位置开始到指定位置结束截取字符串。</li></ul></li></ul><p>###12.09_常见对象(字符串的遍历)(掌握)</p><ul><li>A:案例演示<ul><li>需求：遍历字符串</li></ul></li></ul><p>###12.10_常见对象(统计不同类型字符个数)(掌握)</p><ul><li>A:案例演示<ul><li>需求：统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数,其他字符出现的次数。</li><li>ABCDEabcd123456!@#$%^</li></ul></li></ul><p>###12.11_常见对象(String类的转换功能)(掌握)</p><ul><li>A:String的转换功能：<ul><li>byte[] getBytes():把字符串转换为字节数组。</li><li>char[] toCharArray():把字符串转换为字符数组。</li><li>static String valueOf(char[] chs):把字符数组转成字符串。</li><li>static String valueOf(int i):把int类型的数据转成字符串。<ul><li>注意：String类的valueOf方法可以把任意类型的数据转成字符串。</li></ul></li></ul></li></ul><pre><code>* String toLowerCase():把字符串转成小写。(了解)* String toUpperCase():把字符串转成大写。* String concat(String str):把字符串拼接。</code></pre><p>###12.12_常见对象(按要求转换字符)(链式编程掌握)</p><ul><li>A:案例演示<ul><li>需求：把一个字符串的首字母转成大写，其余为小写。(只考虑英文大小写字母字符)</li></ul></li></ul><p>###12.13_常见对象(把数组转成字符串)</p><ul><li>A:案例演示<ul><li>需求：把数组中的数据按照指定个格式拼接成一个字符串<ul><li>举例：<ul><li>int[] arr = {1,2,3};    </li></ul></li><li>输出结果：<ul><li>“[1, 2, 3]”<br>###12.14_常见对象(String类的其他功能)</li></ul></li></ul></li></ul></li><li>A:String的替换功能及案例演示<ul><li>String replace(char old,char new)</li><li>String replace(String old,String new)</li></ul></li><li>B:String的去除字符串两空格及案例演示<ul><li>String trim()</li></ul></li><li>C:String的按字典顺序比较两个字符串及案例演示<ul><li>int compareTo(String str)(暂时不用掌握)</li><li>int compareToIgnoreCase(String str)(了解)</li></ul></li></ul><p>###12.15_常见对象(字符串反转)</p><ul><li>A:案例演示<ul><li>需求：把字符串反转<ul><li>举例：键盘录入”abc”        </li><li>输出结果：”cba”</li></ul></li></ul></li></ul><p>###12.16_常见对象(在大串中查找小串出现的次数思路图解)</p><ul><li>A:画图演示<ul><li>需求：统计大串中小串出现的次数</li><li>这里的大串和小串可以自己根据情况给出</li></ul></li></ul><p>###12.17_常见对象(在大串中查找小串出现的次数代码实现)</p><ul><li>A:案例演示    <ul><li>统计大串中小串出现的次数</li></ul></li></ul><p><em>String对象的底层实际上是一个char[]数组：private final char value[];<br>用final修饰的对象值可变，但是引用不变，即：value指向不可变，但是value[]数组的值可变，<br>但因为有private关键字对其进行封装达到value[]数组值也不可变的目的</em>而StringBuffer对象的底层也是一个char[]数组：char[] value;<br>但是并没有用final修饰，所以数组的值是可变的。</p><p>##final意义：最终的，不可改变的。<br>　　1、修饰变量，为常量,值不可变；<br>　　2、修饰对象，值可变,引用不变；<br>　　3、修饰方法，方法不可重写；<br>　　4、修饰类，无子类，不可以被继承,更不可能被重写。</p><p>###12.18_day12总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###12.01_常见对象(Scanner的概述和方法介绍)(掌握)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:Scanner的概述&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B:Scanner的构造方法原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scanner(InputStream source)&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="String" scheme="http://zouyip.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://zouyip.github.io/2017/09/05/day10-%E5%86%85%E9%83%A8%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/05/day10-内部类笔记/</id>
    <published>2017-09-05T06:50:33.000Z</published>
    <updated>2017-10-25T01:36:55.341Z</updated>
    
    <content type="html"><![CDATA[<p>###10.01_面向对象(package关键字的概述及作用)(了解)</p><ul><li>A:为什么要有包<ul><li>将字节码(.class)进行分类存放 </li><li>包其实就是文件夹</li></ul></li><li>B:包的概述</li><li><p>  举例：</p><pre><code>学生：增加，删除，修改，查询老师：增加，删除，修改，查询...方案1：按照功能分    com.heima.add        AddStudent        AddTeacher    com.heima.delete        DeleteStudent        DeleteTeacher    com.heima.update        UpdateStudent        UpdateTeacher    com.heima.find        FindStudent        FindTeacher方案2：按照模块分    com.heima.teacher        AddTeacher        DeleteTeacher        UpdateTeacher        FindTeacher    com.heima.student        AddStudent        DeleteStudent        UpdateStudent        FindStudent</code></pre><p>###10.02_面向对象(包的定义及注意事项)(掌握)</p></li><li>A:定义包的格式<ul><li>package 包名;</li><li>多级包用.分开即可</li></ul></li><li>B:定义包的注意事项<ul><li>A:package语句必须是程序的第一条可执行的代码</li><li>B:package语句在一个java文件中只能有一个</li><li>C:如果没有package，默认表示无包名</li></ul></li><li>C:案例演示<ul><li>包的定义及注意事项</li></ul></li></ul><p>###10.03_面向对象(带包的类编译和运行)(掌握)</p><ul><li>A:如何编译运行带包的类<ul><li>a:javac编译的时候带上-d即可<ul><li>javac -d . HelloWorld.java</li></ul></li><li>b:通过java命令执行。<ul><li>java 包名.HellWord<br>###10.04_面向对象(不同包下类之间的访问)(掌握)</li></ul></li></ul></li><li>A:案例演示<ul><li>不同包下类之间的访问</li></ul></li></ul><p>###10.05_面向对象(import关键字的概述和使用)(掌握)</p><ul><li>A:案例演示<ul><li>为什么要有import<ul><li>其实就是让有包的类对调用者可见,不用写全类名了 </li></ul></li></ul></li><li>B:导包格式<ul><li>import 包名;</li><li>注意：</li><li>这种方式导入是到类的名称。</li><li>虽然可以最后写*，但是不建议。</li></ul></li><li>C:package,import,class有没有顺序关系(面试题)</li></ul><p>###10.06_面向对象(四种权限修饰符的测试)(掌握)</p><ul><li>A:案例演示<ul><li>四种权限修饰符</li></ul></li><li>B:结论</li><li><pre><code>            本类     同一个包下(子类和无关类)    不同包下(子类)    不同包下(无关类)private     Y        默认            Y        Yprotected    Y        Y                            Ypublic        Y        Y                            Y                Y</code></pre></li></ul><p>###10.07_面向对象(类及其组成所使用的常见修饰符)(掌握)</p><ul><li>A:修饰符：<ul><li>权限修饰符：private，默认的，protected，public</li><li>状态修饰符：static，final</li><li>抽象修饰符：abstract</li></ul></li><li><p>B:类：</p><ul><li>权限修饰符：默认修饰符，public</li><li>状态修饰符：final</li><li><p>抽象修饰符：abstract</p></li><li><p>用的最多的就是：public</p></li></ul></li><li><p>C:成员变量：</p><ul><li>权限修饰符：private，默认的，protected，public</li><li><p>状态修饰符：static，final</p></li><li><p>用的最多的就是：private</p></li></ul></li><li><p>D:构造方法：</p><ul><li><p>权限修饰符：private，默认的，protected，public</p></li><li><p>用的最多的就是：public</p></li></ul></li><li><p>E:成员方法：</p><ul><li>权限修饰符：private，默认的，protected，public</li><li>状态修饰符：static，final</li><li><p>抽象修饰符：abstract</p></li><li><p>用的最多的就是：public</p></li></ul></li><li><p>F:除此以外的组合规则：</p><ul><li>成员变量：public static final</li><li>成员方法：<ul><li>public static </li><li>public abstract</li><li>public final</li></ul></li></ul></li></ul><p>###10.08_面向对象(内部类概述和访问特点)(了解)</p><ul><li>A:内部类概述</li><li>B:内部类访问特点<ul><li>a:内部类可以直接访问外部类的成员，包括私有。</li><li>b:外部类要访问内部类的成员，必须创建对象。</li><li>外部类名.内部类名 对象名 = 外部类对象.内部类对象;（这种表述是为了让人看懂类中有内部类）</li></ul></li><li>C:案例演示<ul><li>内部类极其访问特点</li></ul></li></ul><p>###10.09_面向对象(成员内部类私有使用)(了解)</p><ul><li>private</li></ul><p>###10.10_面向对象(静态成员内部类)(了解)</p><ul><li>static</li><li>B:成员内部类被静态修饰后的访问方式是:<ul><li>外部类名.内部类名 对象名 = 外部类名.内部类对象;</li></ul></li></ul><p>###10.11_面向对象(成员内部类的面试题)(掌握)</p><ul><li>A:面试题</li><li><pre><code>要求：使用已知的变量，在控制台输出30，20，10。class Outer {    public int num = 10;    class Inner {        public int num = 20;        public void show() {            int num = 30;            System.out.println(?);            System.out.println(??);            System.out.println(???);        }    }}class InnerClassTest {    public static void main(String[] args) {        Outer.Inner oi = new Outer().new Inner();        oi.show();    }    }</code></pre></li></ul><p>###10.12_面向对象(局部内部类访问局部变量的问题)(掌握)</p><ul><li><p>A:案例演示</p><ul><li>局部内部类访问局部变量必须用final修饰</li><li><p>局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么?<br>  因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用</p><p>  但是jdk1.8取消了这个事情,所以我认为这是个bug</p></li></ul></li></ul><p>###10.13_面向对象(匿名内部类的格式和理解)</p><ul><li>A:匿名内部类<ul><li>就是内部类的简化写法。</li></ul></li><li>B:前提：存在一个类或者接口<ul><li>这里的类可以是具体类也可以是抽象类。</li></ul></li><li>C:格式：</li><li><pre><code>new 类名或者接口名(){    重写方法;}</code></pre></li><li>D:本质是什么呢?<ul><li>是一个继承了该类或者实现了该接口的子类匿名对象。</li></ul></li><li>E:案例演示<ul><li>按照要求来一个匿名内部类</li></ul></li></ul><p>###10.14_面向对象(匿名内部类重写多个方法调用)</p><ul><li>A:案例演示<ul><li>匿名内部类的方法调用</li></ul></li></ul><p>###10.15_面向对象(匿名内部类在开发中的应用)</p><ul><li>A:代码如下</li><li><pre><code>//这里写抽象类，接口都行abstract class Person {    public abstract void show();}class PersonDemo {    public void method(Person p) {        p.show();    }}class PersonTest {    public static void main(String[] args) {        //如何调用PersonDemo中的method方法呢?        PersonDemo pd = new PersonDemo ();    }}</code></pre></li></ul><p>###10.16_面向对象(匿名内部类的面试题)</p><ul><li>A:面试题</li><li><pre><code>按照要求，补齐代码interface Inter { void show(); }class Outer { //补齐代码 }class OuterDemo {    public static void main(String[] args) {          Outer.method().show();      }}要求在控制台输出”HelloWorld”</code></pre></li></ul><p>###10.17_day10总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###10.01_面向对象(package关键字的概述及作用)(了解)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:为什么要有包&lt;ul&gt;
&lt;li&gt;将字节码(.class)进行分类存放 &lt;/li&gt;
&lt;li&gt;包其实就是文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:包的概述&lt;/li&gt;

      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="内部类" scheme="http://zouyip.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>equals概述</title>
    <link href="http://zouyip.github.io/2017/09/05/day11-equals%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/05/day11-equals笔记/</id>
    <published>2017-09-05T03:50:33.000Z</published>
    <updated>2017-10-25T01:44:17.902Z</updated>
    
    <content type="html"><![CDATA[<p>###_常见对象(API概述)(了解)</p><ul><li>A:API(Application Programming Interface) <ul><li>应用程序编程接口</li></ul></li><li>B:Java API<ul><li>就是Java提供给我们使用的类，这些类将底层的实现封装了起来，</li><li>我们不需要关心这些类是如何实现的，只需要学习这些类如何使用。</li></ul></li></ul><p>###_常见对象(Object类的概述)(了解)</p><ul><li>A:Object类概述<ul><li>类层次结构的根类</li><li>所有类都直接或者间接的继承自该类</li></ul></li><li>B:构造方法<ul><li>public Object()</li><li>回想面向对象中为什么说：</li><li>子类的构造方法默认访问的是父类的无参构造方法</li></ul></li></ul><p>###_常见对象(Object类的hashCode()方法)(了解)</p><ul><li>A:案例演示<ul><li>public int hashCode()</li><li>a:返回该对象的哈希码值。默认情况下，该方法会根据对象的地址来计算。</li><li>b:不同对象的，hashCode()一般来说不会相同。但是，同一个对象的hashCode()值肯定相同。</li></ul></li></ul><p>###_常见对象(Object类的getClass()方法)(在反射的时候掌握)</p><ul><li>A:案例演示<ul><li>public final Class getClass()</li><li>a:返回此 Object 的运行时类。</li><li>b:可以通过Class类中的一个方法，获取对象的真实类的全名称。    <ul><li>public String getName()</li></ul></li></ul></li></ul><p>###_常见对象(Object类的toString()方法)(掌握)</p><ul><li>A:案例演示<ul><li>public String toString()</li><li>a:返回该对象的字符串表示。</li></ul></li><li><pre><code>public Stirng toString() {    return name + &quot;,&quot; + age;}</code></pre><ul><li>b:它的值等于： <ul><li>getClass().getName() + “@” + Integer.toHexString(hashCode()) </li></ul></li><li>c:由于默认情况下的数据对我们来说没有意义，一般建议重写该方法。</li></ul></li><li>B:最终版<ul><li>自动生成</li></ul></li></ul><p>###_常见对象(Object类的equals()方法)(掌握)</p><ul><li>A:案例演示<ul><li>a:指示其他某个对象是否与此对象“相等”。 </li><li>b:默认情况下比较的是对象的引用是否相同。</li><li>c:由于比较对象的引用没有意义，一般建议重写该方法。</li></ul></li></ul><p>###_常见对象(==号和equals方法的区别)(掌握)</p><ul><li>==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值</li><li>equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,<br>  equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###_常见对象(API概述)(了解)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:API(Application Programming Interface) &lt;ul&gt;
&lt;li&gt;应用程序编程接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:Java API&lt;ul&gt;
&lt;li&gt;就是Jav
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="equals" scheme="http://zouyip.github.io/tags/equals/"/>
    
  </entry>
  
</feed>
