<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟的心酸历程</title>
  
  <subtitle>zyp&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zouyip.github.io/"/>
  <updated>2017-10-25T01:37:47.736Z</updated>
  <id>http://zouyip.github.io/</id>
  
  <author>
    <name>Zou Yipeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通俗地讲RESTFUL</title>
    <link href="http://zouyip.github.io/2017/10/13/%E7%94%A8%E9%80%9A%E4%BF%97%E8%AF%AD%E8%A8%80%E8%AF%B4restful/"/>
    <id>http://zouyip.github.io/2017/10/13/用通俗语言说restful/</id>
    <published>2017-10-13T06:20:33.000Z</published>
    <updated>2017-10-25T01:37:47.736Z</updated>
    
    <content type="html"><![CDATA[<p>####实现了REST规范的Web API就叫RESTful API。</p><p>简单来说：就是用url定位资源，用http描述来操作资源。</p><p>web是什么：分布式信息系统为超文本文件和其他对象（资源）提供访问入口。</p><p>资源是web架构的关键点，需要3个操作：识别，表示，交互。uri(统一资源标识符)来识别资源，html.xml,图片，视频来表示资源，通过协议与资源交互。</p><p>所以rest就是选择通过使用http协议和uri,对资源进行CRUD增删改查操作。</p><p>rest协议是面向资源的，soap是面向服务的，假如要管理一些用户，使用rest协议将用户看做是一种资源：</p><p>get  /users/{userid}  获取userid对应的user信息。     post   /users  创建一个新的user。   put  /users/{userid}  更改userid对应的user信息.</p><p>使用soap将对用户的操作看做成服务：</p><p>我们大部分项目中目前使用的是RPC风格的服务：</p><p>   rpc只能用服务本身提供的方法和接口与服务器交互，整个过程中，请求，响应和方法对于客户端都是不可见的，异构的客户端很难与服务器通信，也很难解析服务器的响应请求。</p><pre><code>restful风格的服务：整个过程采用http方法发生请求，数据采用标准格式，基于统一接口和通用载体，即使客户端和服务器采用不同的技术构建，也不会影响通信。</code></pre><p>顺便说下SOA和微服务的区别：</p><p>SOA的提出是在企业计算领域，就是要将紧耦合的系统，划分为面向业务的，粗粒度，松耦合，无状态的服务。服务发布出来供其他服务调用，一组互相依赖的服务就构成了SOA架构下的系统。</p><p>我们知道企业计算领域，如果不是交易系统的话，并发量都不是很大的，所以大多数情况下，一台服务器就容纳将许许多多的服务，这些服务采用统一的基础设施，可能都运行在一个应用服务器的进程中。虽然说是面向服务了，但还是单一的系统。</p><p>微服务：</p><p>不同的子系统采用自己的架构，那么各个服务运行自己的Web容器中，当需要增加计算能力的时候，只需要增加这个子系统或服务的实例就好了，当升级的时候，可以不影响别的子系统。这种组织方式大体上就被称作微服务架构。</p><p>微服务与SOA相比，更强调分布式系统的特性，比如横向伸缩性，服务发现，负载均衡，故障转移，高可用。互联网开发对服务治理提出了更多的要求，比如多版本，比如灰度升级，比如服务降级，比如分布式跟踪，这些都是在SOA实践中重视不够的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####实现了REST规范的Web API就叫RESTful API。&lt;/p&gt;
&lt;p&gt;简单来说：就是用url定位资源，用http描述来操作资源。&lt;/p&gt;
&lt;p&gt;web是什么：分布式信息系统为超文本文件和其他对象（资源）提供访问入口。&lt;/p&gt;
&lt;p&gt;资源是web架构的关键点，
      
    
    </summary>
    
      <category term="RESTFUL" scheme="http://zouyip.github.io/categories/RESTFUL/"/>
    
    
      <category term="RESTFUL" scheme="http://zouyip.github.io/tags/RESTFUL/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://zouyip.github.io/2017/09/22/day23-%E9%80%92%E5%BD%92%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/22/day23-递归练习笔记/</id>
    <published>2017-09-22T11:20:20.000Z</published>
    <updated>2017-10-26T02:50:13.587Z</updated>
    
    <content type="html"><![CDATA[<p>###23.01_File类递归练习(统计该文件夹大小)</p><ul><li>需求:1,从键盘接收一个文件夹路径,统计该文件夹大小</li></ul><p>###23.02_File类递归练习(删除该文件夹)</p><ul><li>需求:2,从键盘接收一个文件夹路径,删除该文件夹</li></ul><p>###23.03_File类递归练习(拷贝)</p><ul><li>需求:3,从键盘接收两个文件夹路径,把其中一个文件夹中(包含内容)拷贝到另一个文件夹中</li></ul><p>###23.04_File类递归练习(按层级打印)</p><ul><li><p>需求:4,从键盘接收一个文件夹路径,把文件夹中的所有文件以及文件夹的名字按层级打印, 例如:<br>  aaa是文件夹,里面有bbb.txt,ccc.txt,ddd.txt这些文件,有eee这样的文件夹,eee中有fff.txt和ggg.txt,打印出层级来<br>  aaa</p><pre><code>bbb.txtccc.txtddd.txteee    fff.txt    ggg.txt</code></pre></li></ul><p>###23.05_递归练习(斐波那契数列)</p><ul><li>不死神兔</li><li>故事得从西元1202年说起，话说有一位意大利青年，名叫斐波那契。</li><li>在他的一部著作中提出了一个有趣的问题：假设一对刚出生的小兔一个月后就能长成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，一年内没有发生死亡，</li><li>问：一对刚出生的兔子，一年内繁殖成多少对兔子?</li><li>1 1 2 3 5 8 13</li><li>第一个月一对小兔子                    1</li><li>第二个月一对大兔子                    1</li><li>第三个月一对大兔子生了一对小兔子        2</li><li>第四个月一对大兔子生了一对小兔子</li><li>一对小兔子长成大兔子            3</li><li>第五个月两对大兔子生两对小兔子    </li><li>一对小兔子长成大兔子            5</li></ul><p>###23.06_递归练习(1000的阶乘所有零和尾部零的个数)</p><ul><li>需求:求出1000的阶乘所有零和尾部零的个数,不用递归做</li></ul><p>###23.07_递归练习(1000的阶乘尾部零的个数)</p><ul><li>需求:求出1000的阶乘尾部零的个数,用递归做</li></ul><p>###23.08_集合练习(约瑟夫环)</p><ul><li>幸运数字</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###23.01_File类递归练习(统计该文件夹大小)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求:1,从键盘接收一个文件夹路径,统计该文件夹大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###23.02_File类递归练习(删除该文件夹)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求:2,从键盘接收一个文件
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="递归" scheme="http://zouyip.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>多线程-单例模式</title>
    <link href="http://zouyip.github.io/2017/09/22/day25-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/22/day25-多线程-单例模式笔记/</id>
    <published>2017-09-22T11:20:20.000Z</published>
    <updated>2017-10-26T02:52:02.397Z</updated>
    
    <content type="html"><![CDATA[<p>###25.01_多线程(单例设计模式)(掌握)</p><ul><li><p>单例设计模式：保证类在内存中只有一个对象。</p></li><li><p>如何保证类在内存中只有一个对象呢？（3步走）</p><ul><li>(1)控制类的创建，不让其他类来创建本类的对象。private</li><li>(2)在本类中定义一个本类的对象。Singleton s;</li><li>(3)提供公共的访问方式。  public static Singleton getInstance(){return s}</li></ul></li><li><p>单例写法两种：</p><ul><li>(1)饿汉式 开发用这种方式。</li><li><pre><code>//饿汉式（通俗化理解：一来就new对象，像个饿汉一样着急）class Singleton {    //1,私有构造函数    private Singleton(){}    //2,创建本类对象（注意static修饰，通过类名. 调用）    private static Singleton s = new Singleton();    //3,对外提供公共的访问方法（提供get方法得到）    public static Singleton getInstance() {        return s;    }    public static void print() {        System.out.println(&quot;11111111111&quot;);    }}</code></pre></li><li>(2)懒汉式 面试写这种方式。多线程的问题？</li><li><pre><code>//懒汉式,单例的延迟加载模式（先声明对象，不着急new实例化）class Singleton {    //1,私有构造函数    private Singleton(){}    //2,声明一个本类的引用    private static Singleton s;    //3,对外提供公共的访问方法    public static Singleton getInstance() {        if(s == null)            //线程1,线程2            s = new Singleton();        return s;    }    public static void print() {        System.out.println(&quot;11111111111&quot;);    }}</code></pre></li></ul></li></ul><pre><code>    * 饿汉式和懒汉式的区别    * 1,饿汉式是空间换时间,懒汉式是时间换空间    * 2,在多线程访问时,饿汉式不会创建多个对象,而懒汉式有可能会创建多个对象（所以一般开发中使用饿汉式）* (3)第三种格式（了解）*         class Singleton {            private Singleton() {}            public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改        }</code></pre><p>###25.02_多线程(Runtime类)</p><ul><li>Runtime类是一个单例类<ul><li><pre><code>Runtime r = Runtime.getRuntime();//r.exec(&quot;shutdown -s -t 300&quot;);        //300秒后关机r.exec(&quot;shutdown -a&quot;);                //取消关机</code></pre></li></ul></li></ul><p>###25.03_多线程(Timer)(掌握)（计时安排执行任务）</p><ul><li><p>Timer类:计时器（schedule()方法）</p><pre><code>public class Demo5_Timer {    /**     * @param args     * 计时器     * @throws InterruptedException      */    public static void main(String[] args) throws InterruptedException {        Timer t = new Timer();        t.schedule(new MyTimerTask(), new Date(114,9,15,10,54,20),3000);        while(true) {            System.out.println(new Date());            Thread.sleep(1000);        }    }}class MyTimerTask extends TimerTask {    @Override    public void run() {        System.out.println(&quot;起床背英语单词&quot;);    }}</code></pre></li></ul><p>###25.04_多线程(两个线程间的通信)(掌握)</p><ul><li>1.什么时候需要通信<ul><li>多个线程并发执行时, 在默认情况下CPU是随机切换线程的</li><li>如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印</li></ul></li><li>2.怎么通信<ul><li>如果希望线程等待, 就调用wait()</li><li>如果希望唤醒等待的线程, 就调用notify();</li><li>这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用</li></ul></li></ul><p>###25.05_多线程(三个或三个以上间的线程通信)</p><ul><li><p>多个线程通信的问题</p><ul><li>notify()方法是随机唤醒一个线程</li><li>notifyAll()方法是唤醒所有线程</li><li>JDK5之前无法唤醒指定的一个线程</li><li><p>如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件</p><p>/*1,在同步代码块中,用哪个对象锁,就用哪个对象调用wait方法</p><ul><li>2,为什么wait方法和notify方法定义在Object这类中?</li><li>因为锁对象可以是任意对象,Object是所有的类的基类,所以wait方法和notify方法需要定义在Object这个类中</li><li>3,sleep方法和wait方法的区别?</li><li>a,sleep方法必须传入参数,参数就是时间,时间到了自动醒来</li><li>wait方法可以传入参数也可以不传入参数,传入参数就是在参数的时间结束后等待,不传入参数就是直接等待</li><li>b,sleep方法在同步函数或同步代码块中,不释放锁,睡着了也抱着锁睡（cpu一直等待线程结束sleep后继续执行该线程）</li><li>wait方法在同步函数或者同步代码块中,释放锁（进入wait状态是cpu可以离开去执行别的线程）<br>*/ </li></ul></li></ul></li></ul><p>###25.06_多线程(JDK1.5的新特性互斥锁（可替代synchronized）)(掌握)</p><ul><li>1.同步<ul><li>使用ReentrantLock类的lock()和unlock()方法进行同步</li></ul></li><li>2.通信<ul><li>使用ReentrantLock类的newCondition()方法可以获取Condition对象</li><li>需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法（可替代wait()和notify()方法）</li><li>不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了</li></ul></li></ul><p>###25.07_多线程(线程组的概述和使用)(了解)</p><ul><li>A:线程组概述<ul><li>Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</li><li>默认情况下，所有的线程都属于主线程组。<ul><li>public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组</li><li>public final String getName()//通过线程组对象获取他组的名字</li></ul></li><li>我们也可以给线程设置分组<ul><li>1,ThreadGroup(String name) 创建线程组对象并给其赋值名字</li><li>2,创建线程对象</li><li>3,Thread(ThreadGroup?group, Runnable?target, String?name) </li><li>4,设置整组的优先级或者守护线程</li></ul></li><li>B:案例演示<ul><li>线程组的使用,默认是主线程组</li></ul></li></ul></li><li><pre><code>MyRunnable mr = new MyRunnable();Thread t1 = new Thread(mr, &quot;张三&quot;);Thread t2 = new Thread(mr, &quot;李四&quot;);//获取线程组// 线程类里面的方法：public final ThreadGroup getThreadGroup()ThreadGroup tg1 = t1.getThreadGroup();ThreadGroup tg2 = t2.getThreadGroup();// 线程组里面的方法：public final String getName()String name1 = tg1.getName();String name2 = tg2.getName();System.out.println(name1);System.out.println(name2);// 通过结果我们知道了：线程默认情况下属于main线程组// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组System.out.println(Thread.currentThread().getThreadGroup().getName());</code></pre><ul><li>自己设定线程组</li></ul></li><li><p>// ThreadGroup(String name)<br>ThreadGroup tg = new ThreadGroup(“这是一个新的组”);</p><p>MyRunnable mr = new MyRunnable();<br>// Thread(ThreadGroup group, Runnable target, String name)<br>Thread t1 = new Thread(tg, mr, “张三”);<br>Thread t2 = new Thread(tg, mr, “李四”);</p><p>System.out.println(t1.getThreadGroup().getName());<br>System.out.println(t2.getThreadGroup().getName());</p><p>//通过组名称设置后台线程，表示该组的线程都是后台线程<br>tg.setDaemon(true);<br>###25.08_多线程(线程的五种状态)(掌握)</p></li><li>看图说话</li><li>新建,就绪,运行,阻塞,死亡</li></ul><p>###25.09_多线程(线程池的概述和使用)(了解)</p><ul><li>A:线程池概述（一般服务器使用的就是线程池）<ul><li>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，<br>尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，<br>并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。<br>在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</li></ul></li><li>B:内置线程池的使用概述<ul><li>JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法<ul><li>public static ExecutorService newFixedThreadPool(int nThreads)</li><li>public static ExecutorService newSingleThreadExecutor()</li><li>这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法</li><li>Future&lt;?&gt; submit(Runnable task)</li><li><t> Future<t> submit(Callable<t> task)</t></t></t></li></ul></li><li>使用步骤：<ul><li>创建线程池对象</li><li>创建Runnable实例</li><li>提交Runnable实例</li><li>关闭线程池</li></ul></li><li>C:案例演示<ul><li>提交的是Runnable</li></ul></li></ul></li><li><pre><code>// public static ExecutorService newFixedThreadPool(int nThreads)ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程pool.submit(new MyRunnable());pool.submit(new MyRunnable());//结束线程池pool.shutdown();</code></pre></li></ul><p>###25.10_多线程(多线程程序实现的方式3)(了解)</p><ul><li><p>提交的是Callable</p></li><li><pre><code>// 创建线程池对象ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100));Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200));// V get()Integer i1 = f1.get();Integer i2 = f2.get();System.out.println(i1);System.out.println(i2);// 结束pool.shutdown();public class MyCallable implements Callable&lt;Integer&gt; {    private int number;    public MyCallable(int number) {        this.number = number;    }    @Override    public Integer call() throws Exception {        int sum = 0;        for (int x = 1; x &lt;= number; x++) {            sum += x;        }        return sum;    }}</code></pre></li><li><p>多线程程序实现的方式3的好处和弊端</p><ul><li><p>好处：</p><ul><li>可以有返回值</li><li>可以抛出异常</li></ul></li><li><p>弊端：</p><ul><li>代码比较复杂，所以一般不用</li></ul></li></ul></li></ul><p>###25.11_设计模式(简单工厂模式概述和使用)(了解)<br>{一般就是专门用来创建类的实例，这些类一般是父类和若干个子类，他们之间对象实例的创建一般采用工厂模}</p><ul><li>A:简单工厂模式概述<ul><li>又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例</li></ul></li><li>B:优点<ul><li>客户端不需要再负责对象的创建，从而明确了各个类的职责</li></ul></li><li>C:缺点<ul><li>这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护</li></ul></li><li>D:案例演示<ul><li>动物抽象类：public abstract Animal { public abstract void eat(); }</li><li>具体狗类：public class Dog extends Animal {}</li><li>具体猫类：public class Cat extends Animal {}</li><li>开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就制造了一个专门的类来创建对象。</li></ul></li><li><pre><code>public class AnimalFactory {    private AnimalFactory(){}    //public static Dog createDog() {return new Dog();}    //public static Cat createCat() {return new Cat();}    //改进    public static Animal createAnimal(String animalName) {        if(“dog”.equals(animalName)) {return new Dog();}        else if(“cat”.equals(animale)) {            return new Cat();        }else {            return null;        }    }} </code></pre><p>###25.12_设计模式(工厂方法模式的概述和使用)(了解)</p></li><li>A:工厂方法模式概述<ul><li>工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</li></ul></li><li>B:优点<ul><li>客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性</li></ul></li><li>C:缺点<ul><li>需要额外的编写代码，增加了工作量</li></ul></li><li>D:案例演示</li><li><pre><code>动物抽象类：public abstract Animal { public abstract void eat(); }工厂接口：public interface Factory {public abstract Animal createAnimal();}具体狗类：public class Dog extends Animal {}具体猫类：public class Cat extends Animal {}开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。(提供工厂接口，需要创建新类的对象，就创建一个类实现工厂，从而不需要修改工厂。狗工厂：public class DogFactory implements Factory {    public Animal createAnimal() {…}        }猫工厂：public class CatFactory implements Factory {    public Animal createAnimal() {…}        }  </code></pre></li></ul><p>###25.13_GUI(如何创建一个窗口并显示)</p><ul><li>Graphical User Interface(图形用户接口)。</li><li><pre><code>Frame  f = new Frame(“my window”);f.setLayout(new FlowLayout());//设置布局管理器f.setSize(500,400);//设置窗体大小f.setLocation(300,200);//设置窗体出现在屏幕的位置f.setIconImage(Toolkit.getDefaultToolkit().createImage(&quot;qq.png&quot;));f.setVisible(true);</code></pre></li></ul><p>###25.14_GUI(布局管理器)</p><ul><li>FlowLayout（流式布局管理器）<ul><li>从左到右的顺序排列。</li><li>Panel默认的布局管理器。</li></ul></li><li>BorderLayout（边界布局管理器）<ul><li>东，南，西，北，中</li><li>Frame默认的布局管理器。</li></ul></li><li>GridLayout（网格布局管理器）<ul><li>规则的矩阵</li></ul></li><li>CardLayout（卡片布局管理器）<ul><li>选项卡</li></ul></li><li>GridBagLayout（网格包布局管理器）<ul><li>非规则的矩阵<br>###25.15_GUI(窗体监听)<br>Frame f = new Frame(“我的窗体”);<br>//事件源是窗体,把监听器注册到事件源上<br>//事件对象传递给监听器<br>f.addWindowListener(new WindowAdapter() {<pre><code>  public void windowClosing(WindowEvent e) {             //退出虚拟机,关闭窗口System.exit(0);</code></pre>  }<br>});</li></ul></li></ul><p>###25.16_GUI(鼠标监听)</p><p>###25.17_GUI(键盘监听和键盘事件)</p><p>###25.18_GUI(动作监听)</p><p>###25.19_设计模式(适配器设计模式)(掌握)</p><ul><li>a.什么是适配器<ul><li>在使用监听器的时候, 需要定义一个类事件监听器接口.</li><li>通常接口中有多个方法, 而程序中不一定所有的都用到, 但又必须重写, 这很繁琐.</li><li>适配器简化了这些操作, 我们定义监听器时只要继承适配器, 然后重写需要的方法即可.</li></ul></li><li>b.适配器原理<ul><li>适配器就是一个类, 实现了监听器接口, 所有抽象方法都重写了, 但是方法全是空的.</li><li>适配器类需要定义成抽象的,因为创建该类对象,调用空方法是没有意义的</li><li>目的就是为了简化程序员的操作, 定义监听器时继承适配器, 只重写需要的方法就可以了.<br>###25.20_GUI(需要知道的) </li></ul></li><li>事件处理<ul><li>事件: 用户的一个操作</li><li>事件源: 被操作的组件</li><li>监听器: 一个自定义类的对象, 实现了监听器接口, 包含事件处理方法,把监听器添加在事件源上, 当事件发生的时候虚拟机就会自动调用监听器中的事件处理方法<br>###25.21_day25总结<br>把今天的知识点总结一遍。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###25.01_多线程(单例设计模式)(掌握)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单例设计模式：保证类在内存中只有一个对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何保证类在内存中只有一个对象呢？（3步走）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1)控制类的创建，不让其他类来创建本类的
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多线程" scheme="http://zouyip.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="单例模式" scheme="http://zouyip.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://zouyip.github.io/2017/09/22/day24-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/22/day24-多线程笔记/</id>
    <published>2017-09-22T11:20:20.000Z</published>
    <updated>2017-10-26T02:50:52.831Z</updated>
    
    <content type="html"><![CDATA[<p>###24.01_多线程(多线程的引入)(了解)</p><ul><li>1.什么是线程<ul><li>线程是程序执行的一条路径, 一个进程中可以包含多条线程</li><li>多线程并发执行可以提高程序的效率, 可以同时完成多项工作</li></ul></li><li>2.多线程的应用场景<ul><li>红蜘蛛同时共享屏幕给多个电脑</li><li>迅雷开启多条线程一起下载</li><li>QQ同时和多个人一起视频</li><li>服务器同时处理多个客户端请求</li></ul></li></ul><p>###24.02_多线程(多线程并行和并发的区别)(了解)</p><ul><li>并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)</li><li>并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。</li><li>比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。</li><li>如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。</li></ul><p>###24.03_多线程(Java程序运行原理和JVM的启动是多线程的吗)(了解)</p><ul><li><p>A:Java程序运行原理</p><ul><li>Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。</li></ul></li><li><p>B:JVM的启动是多线程的吗</p><ul><li>JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。</li></ul></li></ul><p>###24.04_多线程(多线程程序实现的方式1)(掌握)</p><ul><li><p>1.继承Thread</p><ul><li>定义类继承Thread</li><li>重写run方法</li><li>把新线程要做的事写在run方法中</li><li>创建线程对象</li><li>开启新线程, 内部会自动执行run方法</li><li><pre><code>public class Demo2_Thread {    /**     * @param args     */    public static void main(String[] args) {        MyThread mt = new MyThread();                            //4,创建自定义类的对象        mt.start();                                                //5,开启线程        for(int i = 0; i &lt; 3000; i++) {            System.out.println(&quot;bb&quot;);        }    }}class MyThread extends Thread {                                    //1,定义类继承Thread    public void run() {                                            //2,重写run方法        for(int i = 0; i &lt; 3000; i++) {                            //3,将要执行的代码,写在run方法中            System.out.println(&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;);        }    }}</code></pre></li></ul></li></ul><p>###24.05_多线程(多线程程序实现的方式2)(掌握)</p><ul><li><p>2.实现Runnable</p><ul><li>定义类实现Runnable接口</li><li>实现run方法</li><li>把新线程要做的事写在run方法中</li><li>创建自定义的Runnable的子类对象</li><li>创建Thread对象, 传入Runnable</li><li><p>调用start()开启新线程, 内部会自动调用Runnable的run()方法</p><pre><code>public class Demo3_Runnable {    /**     * @param args     */    public static void main(String[] args) {        MyRunnable mr = new MyRunnable();                        //4,创建自定义类对象        //Runnable target = new MyRunnable();        Thread t = new Thread(mr);                                //5,将其当作参数传递给Thread的构造函数        t.start();                                                //6,开启线程        for(int i = 0; i &lt; 3000; i++) {            System.out.println(&quot;bb&quot;);        }    }}class MyRunnable implements Runnable {                            //1,自定义类实现Runnable接口    @Override    public void run() {                                            //2,重写run方法        for(int i = 0; i &lt; 3000; i++) {                            //3,将要执行的代码,写在run方法中            System.out.println(&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;);        }    }}</code></pre></li></ul></li></ul><p>###24.06_多线程(实现Runnable的原理)(了解)</p><ul><li>查看源码<ul><li>1,看Thread类的构造函数,传递了Runnable接口的引用 </li><li>2,通过init()方法找到传递的target给成员变量的target赋值</li><li>3,查看run方法,发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法</li></ul></li></ul><p>###24.07_多线程(两种方式的区别)(掌握)</p><ul><li><p>查看源码的区别:</p><ul><li>a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法（这种是直接找子类的run()方法）</li><li>b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用<pre><code>是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法</code></pre></li></ul></li><li><p>继承Thread</p><ul><li>好处是:可以直接使用Thread类中的方法,代码简单</li><li>弊端是:如果已经有了父类,就不能用这种方法</li></ul></li><li>实现Runnable接口<ul><li>好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的</li><li>弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂<br>###24.08_多线程(匿名内部类实现线程的两种方式)(掌握)</li></ul></li><li><p>继承Thread类</p><pre><code>new Thread() {                                                    //1,new 类(){}继承这个类    public void run() {                                            //2,重写run方法        for(int i = 0; i &lt; 3000; i++) {                            //3,将要执行的代码,写在run方法中            System.out.println(&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;);        }    }}.start();</code></pre></li><li><p>实现Runnable接口</p><pre><code>new Thread(new Runnable(){                                        //1,new 接口(){}实现这个接口    public void run() {                                            //2,重写run方法        for(int i = 0; i &lt; 3000; i++) {                            //3,将要执行的代码,写在run方法中            System.out.println(&quot;bb&quot;);        }    }}).start(); </code></pre></li></ul><p>###24.09_多线程(获取名字和设置名字)(掌握)</p><ul><li>1.获取名字<ul><li>通过getName()方法获取线程对象的名字</li></ul></li><li><p>2.设置名字</p><ul><li>通过构造函数可以传入String类型的名字</li><li><pre><code>new Thread(&quot;xxx&quot;) {    public void run() {        for(int i = 0; i &lt; 1000; i++) {            System.out.println(this.getName() + &quot;....aaaaaaaaaaaaaaaaaaaaaaa&quot;);        }    }}.start();new Thread(&quot;yyy&quot;) {    public void run() {        for(int i = 0; i &lt; 1000; i++) {            System.out.println(this.getName() + &quot;....bb&quot;);        }    }}.start(); </code></pre></li><li>通过setName(String)方法可以设置线程对象的名字</li><li><pre><code>Thread t1 = new Thread() {    public void run() {        for(int i = 0; i &lt; 1000; i++) {            System.out.println(this.getName() + &quot;....aaaaaaaaaaaaaaaaaaaaaaa&quot;);        }    }};Thread t2 = new Thread() {    public void run() {        for(int i = 0; i &lt; 1000; i++) {            System.out.println(this.getName() + &quot;....bb&quot;);        }    }};t1.setName(&quot;芙蓉姐姐&quot;);t2.setName(&quot;凤姐&quot;);t1.start();t2.start();</code></pre></li></ul></li></ul><p>###24.10_多线程(获取当前线程的对象)(掌握)</p><ul><li><p>Thread.currentThread(), 主线程也可以获取</p><ul><li><pre><code>new Thread(new Runnable() {    public void run() {        for(int i = 0; i &lt; 1000; i++) {            System.out.println(Thread.currentThread().getName() + &quot;...aaaaaaaaaaaaaaaaaaaaa&quot;);        }    }}).start();new Thread(new Runnable() {    public void run() {        for(int i = 0; i &lt; 1000; i++) {            System.out.println(Thread.currentThread().getName() + &quot;...bb&quot;);        }    }}).start();Thread.currentThread().setName(&quot;我是主线程&quot;);                    //获取主函数线程的引用,并改名字System.out.println(Thread.currentThread().getName());        //获取主函数线程的引用,并获取名字</code></pre><p>###24.11_多线程(休眠线程)(掌握)</p></li></ul></li><li><p>Thread.sleep(毫秒,纳秒), 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 <em> 1000 </em> 1000纳秒 1000000000</p><pre><code>new Thread() {    public void run() {        for(int i = 0; i &lt; 10; i++) {            System.out.println(getName() + &quot;...aaaaaaaaaaaaaaaaaaaaaa&quot;);            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}.start();new Thread() {    public void run() {        for(int i = 0; i &lt; 10; i++) {            System.out.println(getName() + &quot;...bb&quot;);            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}.start();</code></pre><p>###24.12_多线程(守护线程)(掌握)</p></li><li><p>setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出</p><ul><li><pre><code>Thread t1 = new Thread() {    public void run() {        for(int i = 0; i &lt; 50; i++) {            System.out.println(getName() + &quot;...aaaaaaaaaaaaaaaaaaaaaa&quot;);            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }};Thread t2 = new Thread() {    public void run() {        for(int i = 0; i &lt; 5; i++) {            System.out.println(getName() + &quot;...bb&quot;);            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }};t1.setDaemon(true);                        //将t1设置为守护线程t1.start();t2.start();</code></pre><p>###24.13_多线程(加入线程)(掌握)</p></li></ul></li><li>join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续</li><li><p>join(int), 可以等待指定的毫秒之后继续</p><ul><li><pre><code>final Thread t1 = new Thread() {    public void run() {        for(int i = 0; i &lt; 50; i++) {            System.out.println(getName() + &quot;...aaaaaaaaaaaaaaaaaaaaaa&quot;);            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }};Thread t2 = new Thread() {    public void run() {        for(int i = 0; i &lt; 50; i++) {            if(i == 2) {                try {                    //t1.join();                        //插队,加入                    t1.join(30);                        //加入,有固定的时间,过了固定时间,继续交替执行                    Thread.sleep(10);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            System.out.println(getName() + &quot;...bb&quot;);        }    }};t1.start();t2.start();</code></pre><p>###24.14_多线程(礼让线程)(了解)</p></li></ul></li><li>yield让出cpu</li></ul><p>###24.15_多线程(设置线程的优先级)(了解)</p><ul><li>setPriority()设置线程的优先级（设置了之后有一定的优先效果，但不是很明显）不是绝对优先的</li></ul><p>###24.16_多线程(同步代码块)(掌握)  [String常量池会有缓存，所以同步synchronize中都不使用String作为锁对象]<br>（锁对象不能用匿名对象,因为匿名对象不是同一个对象<br>    eg：synchronized(new Demo()){…}）</p><ul><li>1.什么情况下需要同步<ul><li>当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.</li><li>如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.</li></ul></li><li>2.同步代码块<ul><li>使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块</li><li>多个同步代码块如果使用相同的锁对象, 那么他们就是同步的</li></ul></li></ul><pre><code>class Printer {    Demo d = new Demo();    public static void print1() {        synchronized(d){                //锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象            System.out.print(&quot;黑&quot;);            System.out.print(&quot;马&quot;);            System.out.print(&quot;程&quot;);            System.out.print(&quot;序&quot;);            System.out.print(&quot;员&quot;);            System.out.print(&quot;\r\n&quot;);        }    }    public static void print2() {            synchronized(d){                System.out.print(&quot;传&quot;);            System.out.print(&quot;智&quot;);            System.out.print(&quot;播&quot;);            System.out.print(&quot;客&quot;);            System.out.print(&quot;\r\n&quot;);        }    }}</code></pre><p>###24.17_多线程(同步方法)(掌握)</p><ul><li>使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的<pre><code>class Printer {    public static void print1() {        synchronized(Printer.class){                //锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象            System.out.print(&quot;黑&quot;);            System.out.print(&quot;马&quot;);            System.out.print(&quot;程&quot;);            System.out.print(&quot;序&quot;);            System.out.print(&quot;员&quot;);            System.out.print(&quot;\r\n&quot;);        }    }    /*     * 非静态同步函数的锁是:this     * 静态的同步函数的锁是:字节码对象（static修饰的在类加载的时候一起加载的，所以锁对象是该类的字节码对象）     */    public static synchronized void print2() {            System.out.print(&quot;传&quot;);        System.out.print(&quot;智&quot;);        System.out.print(&quot;播&quot;);        System.out.print(&quot;客&quot;);        System.out.print(&quot;\r\n&quot;);    }}</code></pre></li></ul><p>###24.18_多线程(线程安全问题)(掌握)</p><ul><li>多线程并发操作同一数据时, 就有可能出现线程安全问题</li><li><p>使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作</p><pre><code>public class Demo2_Synchronized {    /**     * @param args     * 需求:铁路售票,一共100张,通过四个窗口卖完.     */    public static void main(String[] args) {        TicketsSeller t1 = new TicketsSeller();        TicketsSeller t2 = new TicketsSeller();        TicketsSeller t3 = new TicketsSeller();        TicketsSeller t4 = new TicketsSeller();        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t4.setName(&quot;窗口4&quot;);        t1.start();        t2.start();        t3.start();        t4.start();    }}class TicketsSeller extends Thread {    private static int tickets = 100;    static Object obj = new Object();    public TicketsSeller() {        super();    }    public TicketsSeller(String name) {        super(name);    }    public void run() {        while(true) {            synchronized(obj) {                if(tickets &lt;= 0)                     break;                try {                    Thread.sleep(10);//线程1睡,线程2睡,线程3睡,线程4睡                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(getName() + &quot;...这是第&quot; + tickets-- + &quot;号票&quot;);            }        }    }}</code></pre></li></ul><p>###24.19_多线程(火车站卖票的例子用实现Runnable接口)(掌握)    </p><p>###24.20_多线程(死锁)(了解)</p><ul><li><p>多线程同步的时候, 如果同步代码嵌套, 使用相同锁(外层的锁对象跟另一线程的内层嵌套的锁对象是同一个锁), 就有可能出现死锁</p><ul><li><p>尽量不要嵌套使用</p><pre><code>private static String s1 = &quot;筷子左&quot;;private static String s2 = &quot;筷子右&quot;;public static void main(String[] args) {    new Thread() {        public void run() {            while(true) {                synchronized(s1) {                    System.out.println(getName() + &quot;...拿到&quot; + s1 + &quot;等待&quot; + s2);                    synchronized(s2) {                        System.out.println(getName() + &quot;...拿到&quot; + s2 + &quot;开吃&quot;);                    }                }            }        }    }.start();    new Thread() {        public void run() {            while(true) {                synchronized(s2) {                    System.out.println(getName() + &quot;...拿到&quot; + s2 + &quot;等待&quot; + s1);                    synchronized(s1) {                        System.out.println(getName() + &quot;...拿到&quot; + s1 + &quot;开吃&quot;);                    }                }            }        }    }.start();}</code></pre></li></ul></li></ul><p>###24.21_多线程(以前的线程安全的类回顾)(掌握)</p><ul><li>A:回顾以前说过的线程安全问题<ul><li>看源码：Vector,StringBuffer,Hashtable,Collections.synchroinzed(xxx)</li><li>Vector是线程安全的,ArrayList是线程不安全的</li><li>StringBuffer是线程安全的,StringBuilder是线程不安全的</li><li>Hashtable是线程安全的,HashMap是线程不安全的<br>###24.22_多线程(总结)    </li></ul></li></ul><p>*阻塞状态:<br>    什么是阻塞状态呢？，是指当一个线程想获取自己的一个内置的对象锁的时候，这个对象锁被其他线程所占用，<br>    该线程不能执行这个就是阻塞状态，除非当另外一个线程释放锁，并且操作系统允许它执行他才变为非阻塞状态。<br>    这个怎么理解呢其实锁是分为对象锁和类锁 每一个对象都有一个内置的锁 ，在遇到同步的方法或则同步块也就是<br>    被Synchronized修饰的方法 或则使用synchronized的同步块，那么如果一个继承了Thread类或则实现了 Runnable接口的类<br>    下面我们创建了两个线程 这两个线程是实例了相同类创建不同的两个对象，分别启动了开启线程方法start()，<br>    因为我们在run方法中加了同步块，而同步块的锁是这个类的类锁，所以只要是这个类的实例对象都可以得到这个锁，<br>    但是我们都知道类锁只有一把，那个线程先抢到，谁就拥有执行权力，等到这个线程执行完了，释放锁其他线程才能执行。<br>    而没有得到锁的线程他的状态就是阻塞状态，等到拿到锁的线程执行完了，再把锁给它，它就是非阻塞状态了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###24.01_多线程(多线程的引入)(了解)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.什么是线程&lt;ul&gt;
&lt;li&gt;线程是程序执行的一条路径, 一个进程中可以包含多条线程&lt;/li&gt;
&lt;li&gt;多线程并发执行可以提高程序的效率, 可以同时完成多项工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="多线程" scheme="http://zouyip.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IO其他流补充</title>
    <link href="http://zouyip.github.io/2017/09/18/day22-IO%E5%85%B6%E4%BB%96%E6%B5%81%E8%A1%A5%E5%85%85%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/18/day22-IO其他流补充笔记/</id>
    <published>2017-09-18T11:20:20.000Z</published>
    <updated>2017-10-26T02:49:24.336Z</updated>
    
    <content type="html"><![CDATA[<p>###22.01_IO流(序列流)(了解)</p><ul><li>1.什么是序列流<ul><li>序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.</li></ul></li><li><p>2.使用方式</p><ul><li>整合两个: SequenceInputStream(InputStream, InputStream)</li><li><pre><code>FileInputStream fis1 = new FileInputStream(&quot;a.txt&quot;);            //创建输入流对象,关联a.txtFileInputStream fis2 = new FileInputStream(&quot;b.txt&quot;);            //创建输入流对象,关联b.txtSequenceInputStream sis = new SequenceInputStream(fis1, fis2);    //将两个流整合成一个流FileOutputStream fos = new FileOutputStream(&quot;c.txt&quot;);            //创建输出流对象,关联c.txtint b;while((b = sis.read()) != -1) {                                    //用整合后的读    fos.write(b);                                                //写到指定文件上}sis.close();fos.close(); </code></pre><p>###22.02_IO流(序列流整合多个)(了解)</p></li></ul></li><li>整合多个: SequenceInputStream(Enumeration)</li><li><pre><code>FileInputStream fis1 = new FileInputStream(&quot;a.txt&quot;);    //创建输入流对象,关联a.txtFileInputStream fis2 = new FileInputStream(&quot;b.txt&quot;);    //创建输入流对象,关联b.txtFileInputStream fis3 = new FileInputStream(&quot;c.txt&quot;);    //创建输入流对象,关联c.txtVector&lt;InputStream&gt; v = new Vector&lt;&gt;();                    //创建vector集合对象v.add(fis1);                                            //将流对象添加v.add(fis2);v.add(fis3);Enumeration&lt;InputStream&gt; en = v.elements();                //获取枚举引用SequenceInputStream sis = new SequenceInputStream(en);    //传递给SequenceInputStream构造FileOutputStream fos = new FileOutputStream(&quot;d.txt&quot;);int b;while((b = sis.read()) != -1) {    fos.write(b);}sis.close();        //sis在关闭的时候,会将构造方法中传入的流对象也都关闭fos.close();</code></pre></li></ul><ul><li><p>FileInputStream读取中文的时候出现了乱码</p><ul><li>解决方案</li><li>1,字符流读取</li><li><p>2,ByteArrayOutputStream</p><p>###22.03_IO流(内存输出流<strong>*</strong>)(掌握)</p></li></ul></li><li>1.什么是内存输出流<ul><li>该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据</li></ul></li><li><p>2.使用方式</p><ul><li>创建对象: new ByteArrayOutputStream()</li><li>写出数据: write(int), write(byte[])</li><li>获取数据: toByteArray()</li><li><pre><code>FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);ByteArrayOutputStream baos = new ByteArrayOutputStream();        //在内存中创建了可以增长的内存数组int b;while((b = fis.read()) != -1) {    baos.write(b);                //将读取到的数据逐个写到内存中}//byte[] newArr = baos.toByteArray();                //将内存缓冲区中所有的字节存储在newArr中//System.out.println(new String(newArr));System.out.println(baos);fis.close();</code></pre><p>###22.04_IO流(内存输出流之黑马面试题)(掌握)</p></li></ul></li><li>定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5)</li><li><pre><code>FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);                //创建字节输入流,关联a.txtByteArrayOutputStream baos = new ByteArrayOutputStream();        //创建内存输出流byte[] arr = new byte[5];                                        //创建字节数组,大小为5int len;while((len = fis.read(arr)) != -1) {                            //将文件上的数据读到字节数组中    baos.write(arr, 0, len);                                    //将字节数组的数据写到内存缓冲区中}System.out.println(baos);                                        //将内存缓冲区的内容转换为字符串打印fis.close();</code></pre></li></ul><p>###22.05_IO流(对象操作流ObjecOutputStream)(了解)</p><ul><li>1.什么是对象操作流（注意：要实现对象的序列化的前提是定义该类是要实现Serializable接口 <ul><li>该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.（写出为序列化，读取为反序列化）<br>（打开文件看到的是乱码也没关系，能正确的读出啦就可以了）</li></ul></li><li><p>2.使用方式</p><ul><li><p>写出: new ObjectOutputStream(OutputStream), writeObject()</p><pre><code>public class Demo3_ObjectOutputStream {    /**     * @param args     * @throws IOException      * 将对象写出,序列化     */    public static void main(String[] args) throws IOException {        Person p1 = new Person(&quot;张三&quot;, 23);        Person p2 = new Person(&quot;李四&quot;, 24);//        FileOutputStream fos = new FileOutputStream(&quot;e.txt&quot;);//        fos.write(p1);//        FileWriter fw = new FileWriter(&quot;e.txt&quot;);//        fw.write(p1);        //无论是字节输出流,还是字符输出流都不能直接写出对象        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;e.txt&quot;));//创建对象输出流        oos.writeObject(p1);        oos.writeObject(p2);        oos.close();    }}</code></pre><p>###22.06_IO流(对象操作流ObjectInputStream)(了解)</p></li></ul></li><li><p>读取: new ObjectInputStream(InputStream), readObject()</p><ul><li><pre><code>public class Demo3_ObjectInputStream {    /**     * @param args     * @throws IOException      * @throws ClassNotFoundException      * @throws FileNotFoundException      * 读取对象,反序列化     */    public static void main(String[] args) throws IOException, ClassNotFoundException {        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;e.txt&quot;));        Person p1 = (Person) ois.readObject();        Person p2 = (Person) ois.readObject();        System.out.println(p1);        System.out.println(p2);        ois.close();    }}</code></pre></li></ul></li></ul><p>###22.07_IO流(对象操作流优化)(了解)<br>*　将对象存储在集合中写出</p><pre><code>Person p1 = new Person(&quot;张三&quot;, 23);Person p2 = new Person(&quot;李四&quot;, 24);Person p3 = new Person(&quot;马哥&quot;, 18);Person p4 = new Person(&quot;辉哥&quot;, 20);ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;();list.add(p1);list.add(p2);list.add(p3);list.add(p4);ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;f.txt&quot;));oos.writeObject(list);                                    //写出集合对象oos.close();</code></pre><ul><li><p>读取到的是一个集合对象</p><pre><code>ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;f.txt&quot;));    ArrayList&lt;Person&gt; list = (ArrayList&lt;Person&gt;)ois.readObject();    //泛型在运行期会被擦除,所以运行期相当于没有泛型                                                                    //想去掉黄色可以加注解                    @SuppressWarnings(&quot;unchecked&quot;)    for (Person person : list) {        System.out.println(person);    }ois.close();</code></pre><p>###22.08_IO流(加上id号)(了解)</p></li><li>注意<ul><li>要写出的对象必须实现Serializable接口才能被序列化</li><li>不用必须加id号</li></ul></li></ul><p>###22.09_IO流(打印流的概述和特点)(掌握)</p><ul><li><p>1.什么是打印流</p><ul><li>该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式</li><li><p>System.out就是一个PrintStream, 其默认向控制台输出信息</p><pre><code>PrintStream ps = System.out;ps.println(97);                    //其实底层用的是Integer.toString(x),将x转换为数字字符串打印ps.println(&quot;xxx&quot;);ps.println(new Person(&quot;张三&quot;, 23));Person p = null;ps.println(p);                    //如果是null,就返回null,如果不是null,就调用对象的toString()</code></pre></li></ul></li><li>2.使用方式<ul><li>打印: print(), println()</li><li>（用于字符流）自动刷出: PrintWriter(OutputStream out, boolean autoFlush, String encoding)  自动刷出功能没有什么用，了解即可</li><li>打印流只操作数据目的</li></ul></li><li><p>PrintStream和PrintWriter分别是打印的字节流和字符流</p><ul><li><p>只操作数据目的的（即操作Out的部分）</p><p>PrintWriter pw = new PrintWriter(new FileOutputStream(“g.txt”), true);<br>pw.write(97);<br>pw.print(“大家好”);<br>pw.println(“你好”);    //自动刷出,只针对的是println方法，在执行println()方法的时候回执行一次自动刷出，将缓存区的内容刷新出来<br>pw.close();</p></li></ul></li></ul><p>###22.10_IO流(标准输入输出流概述和输出语句)</p><ul><li>1.什么是标准输入输出流(掌握)<ul><li>System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据</li><li>System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据</li></ul></li><li><p>2.修改标准输入输出流(了解)</p><ul><li>修改输入流: System.setIn(InputStream)</li><li>修改输出流: System.setOut(PrintStream)</li><li><pre><code>System.setIn(new FileInputStream(&quot;a.txt&quot;));                //修改标准输入流System.setOut(new PrintStream(&quot;b.txt&quot;));                //修改标准输出流InputStream in = System.in;                                //获取标准输入流PrintStream ps = System.out;                            //获取标准输出流int b;while((b = in.read()) != -1) {                            //从a.txt上读取数据    ps.write(b);                                        //将数据写到b.txt上}in.close();ps.close();</code></pre><p>###22.11_IO流(修改标准输入输出流拷贝图片)(了解)<br>  System.setIn(new FileInputStream(“IO图片.png”));        //改变标准输入流<br>  System.setOut(new PrintStream(“copy.png”));         //改变标准输出流</p><p>  InputStream is = System.in;                            //获取标准输入流<br>  PrintStream ps = System.out;                        //获取标准输出流</p><p>  int len;<br>  byte[] arr = new byte[1024 * 8];                    //为了效率高一点，使用数组的方式来复制</p><p>  while((len = is.read(arr)) != -1) {</p><pre><code>ps.write(arr, 0, len);</code></pre><p>  }</p><p>  is.close();<br>  ps.close();<br>###22.11_IO流(两种方式实现键盘录入)(了解)</p></li></ul></li><li>A:BufferedReader的readLine方法。<ul><li>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</li></ul></li><li>B:Scanner</li></ul><p>###22.12_IO流(随机访问流概述和读写数据)(了解)    、</p><ul><li><p>A:随机访问流概述</p><ul><li>RandomAccessFile概述            有seek()方法        raf.seek(0);//在指定位置设置指针 （安卓部分（多线程下载）使用的多）</li><li>RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。</li><li>支持对随机访问文件的读取和写入。</li></ul></li><li><p>B:read(),write(),seek()</p></li></ul><p>###22.13_IO流(数据输入输出流)(了解)    （打开文件看到的是乱码也没关系，能正确的读出啦就可以了）</p><ul><li>1.什么是数据输入输出流<ul><li>DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据</li><li>例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.（int 类型4个字节）</li></ul></li><li><p>2.使用方式</p><ul><li><p>DataOutputStream(OutputStream), writeInt(), writeLong() </p><pre><code>DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;b.txt&quot;));dos.writeInt(997);dos.writeInt(998);dos.writeInt(999);dos.close();</code></pre></li><li><p>DataInputStream(InputStream), readInt(), readLong()</p><pre><code>DataInputStream dis = new DataInputStream(new FileInputStream(&quot;b.txt&quot;));int x = dis.readInt();int y = dis.readInt();int z = dis.readInt();System.out.println(x);System.out.println(y);System.out.println(z);dis.close();</code></pre><p>###22.14_IO流(Properties的概述和作为Map集合的使用)(了解)</p></li></ul></li><li>A:Properties的概述（Properties是Hashtable的子类）<ul><li>Properties 类表示了一个持久的属性集。</li><li>Properties 可保存在流中或从流中加载。<br><em>*</em> 属性列表中每个键及其对应值都是一个字符串。 </li></ul></li><li>B:案例演示<ul><li>Properties作为Map集合的使用</li></ul></li></ul><p>###22.15_IO流(Properties的特殊功能使用)(了解)</p><ul><li>A:Properties的特殊功能<ul><li>public Object setProperty(String key,String value)</li><li>public String getProperty(String key)</li><li>public Enumeration<string> stringPropertyNames()</string></li></ul></li><li>B:案例演示<ul><li>Properties的特殊功能</li></ul></li></ul><p>###22.16_IO流(Properties的load()和store()功能)(了解)<br>prop.store(new FileOutputStream(“config.properties”), null);//第二个参数是对列表参数的描述,可以给值,也可以给null</p><ul><li>A:Properties的load()和store()功能</li><li>B:案例演示<ul><li>Properties的load()和store()功能</li></ul></li></ul><p>###22.17_day22总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###22.01_IO流(序列流)(了解)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.什么是序列流&lt;ul&gt;
&lt;li&gt;序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="IO流" scheme="http://zouyip.github.io/tags/IO%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>IO字符流、装饰者模式</title>
    <link href="http://zouyip.github.io/2017/09/18/day21-IO%E5%AD%97%E7%AC%A6%E6%B5%81%E3%80%81%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/18/day21-IO字符流、装饰者模式笔记/</id>
    <published>2017-09-18T01:25:20.000Z</published>
    <updated>2017-10-26T02:49:17.487Z</updated>
    
    <content type="html"><![CDATA[<p>###21.01_IO流(字符流FileReader)</p><ul><li>1.字符流是什么<ul><li>字符流是可以直接读写字符的IO流</li><li>字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出.    </li></ul></li><li>2.FileReader<ul><li>FileReader类的read()方法可以按照字符大小读取</li></ul></li><li><pre><code>FileReader fr = new FileReader(&quot;aaa.txt&quot;);                //创建输入流对象,关联aaa.txtint ch;while((ch = fr.read()) != -1) {                            //将读到的字符赋值给ch    System.out.println((char)ch);                        //将读到的字符强转后打印}fr.close();                                                //关流 </code></pre></li></ul><p>###21.02_IO流(字符流FileWriter)</p><ul><li><p>FileWriter类的write()方法可以自动把字符转为字节写出</p><pre><code>FileWriter fw = new FileWriter(&quot;aaa.txt&quot;);fw.write(&quot;aaa&quot;);fw.close();</code></pre></li></ul><p>###21.03_IO流(字符流的拷贝)<br>    FileReader fr = new FileReader(“a.txt”);<br>    FileWriter fw = new FileWriter(“b.txt”);</p><pre><code>int ch;while((ch = fr.read()) != -1) {    fw.write(ch);}fr.close();fw.close();            //Writer类中有一个2k的小缓冲区,如果不关流,就会将内容写到缓冲区里,关流会将缓冲区内容刷新,再关闭###21.04_IO流(什么情况下使用字符流)</code></pre><ul><li>字符流也可以拷贝文本文件, 但不推荐使用. 因为读取时会把字节转为字符, 写出时还要把字符转回字节.</li><li>程序需要读取一段文本, 或者需要写出一段文本的时候可以使用字符流</li><li>读取的时候是按照字符的大小读取的,不会出现半个中文</li><li>写出的时候可以直接将字符串写出,不用转换为字节数组</li></ul><p>###21.05_IO流(字符流是否可以拷贝非纯文本的文件)</p><ul><li>不可以拷贝非纯文本的文件</li><li>因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符(在unicode码表中找不到对应的字符）,就会用?代替,</li><li>写出的时候会将字符转换成字节写出去</li><li>如果是?,直接写出,这样写出之后的文件就乱了,看不了了  </li></ul><p>###21.06_IO流(自定义字符数组的拷贝)</p><ul><li><p>   FileReader fr = new FileReader(“aaa.txt”);            //创建字符输入流,关联aaa.txt<br>   FileWriter fw = new FileWriter(“bbb.txt”);            //创建字符输出流,关联bbb.txt</p><p>   int len;<br>   char[] arr = new char[1024*8];                        //创建字符数组<br>   while((len = fr.read(arr)) != -1) {                    //将数据读到字符数组中</p><pre><code>fw.write(arr, 0, len);                            //从字符数组将数据写到文件上</code></pre><p>   }</p><p>   fr.close();                                            //关流释放资源<br>   fw.close();                                                </p></li></ul><p>###21.07_IO流(带缓冲的字符流) </p><ul><li>BufferedReader的read()方法读取字符时会一次读取若干字符到缓冲区, 然后逐个返回给程序, 降低读取文件的次数, 提高效率</li><li>BufferedWriter的write()方法写出字符时会先写到缓冲区, 缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率</li><li><pre><code>BufferedReader br = new BufferedReader(new FileReader(&quot;aaa.txt&quot;));    //创建字符输入流对象,关联aaa.txtBufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bbb.txt&quot;));    //创建字符输出流对象,关联bbb.txtint ch;                while((ch = br.read()) != -1) {        //read一次,会先将缓冲区读满,从缓冲去中一个一个的返给临时变量ch    bw.write(ch);                    //write一次,是将数据装到字符数组,装满后再一起写出去}br.close();                            //关流bw.close();                          </code></pre></li></ul><p>###21.08_IO流(readLine()和newLine()方法)</p><ul><li><p>带缓冲区的流中的特殊方法</p><ul><li>readLine()</li><li>newLine();</li><li></li><li>newLine()与\r\n的区别</li><li>newLine()是跨平台的方法</li><li>\r\n只支持的是windows系统</li></ul></li><li><p>BufferedReader的readLine()方法可以读取一行字符(不包含换行符号)</p></li><li>BufferedWriter的newLine()可以输出一个跨平台的换行符号”\r\n”</li><li><pre><code>BufferedReader br = new BufferedReader(new FileReader(&quot;aaa.txt&quot;));BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bbb.txt&quot;));String line;while((line = br.readLine()) != null) {    bw.write(line);    //bw.write(&quot;\r\n&quot;);                    //只支持windows系统    bw.newLine();                        //跨平台的}br.close();bw.close(); </code></pre></li></ul><p>###21.09_IO流(将文本反转)</p><ul><li>将一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换</li></ul><p>###21.10_IO流(LineNumberReader) </p><ul><li>LineNumberReader是BufferedReader的子类, 具有相同的功能, 并且可以统计行号<ul><li>调用getLineNumber()方法可以获取当前行号</li><li>调用setLineNumber()方法可以设置当前行号</li></ul></li><li><pre><code>LineNumberReader lnr = new LineNumberReader(new FileReader(&quot;aaa.txt&quot;));String line;lnr.setLineNumber(100);            //设置行号为100，则行号从101开始。因为源码中的（lineNumber++）lineNumber先加了1while((line = lnr.readLine()) != null) {    System.out.println(lnr.getLineNumber() + &quot;:&quot; + line);//获取行号}lnr.close(); </code></pre></li></ul><p>###21.11_IO流(装饰设计模式)</p><ul><li><pre><code>interface Coder {    public void code();}class Student implements Coder {    @Override    public void code() {        System.out.println(&quot;javase&quot;);        System.out.println(&quot;javaweb&quot;);    }}class HeiMaStudent implements Coder {    //1,获取被装饰类的引用    private Student s;                        //获取到被包装的类的引用    //2,在构造方法中传入被装饰类的对象    public HeiMaStudent(Student s) {        //通过构造函数创建对象的时候,传入被包装的对象        this.s = s;    }    //3,对原有的功能进行升级    @Override    public void code() {                    //对其原有功能进行升级        s.code();        System.out.println(&quot;数据库&quot;);        System.out.println(&quot;ssh&quot;);        System.out.println(&quot;安卓&quot;);        System.out.println(&quot;.....&quot;);    }} * 装饰设计模式的好处是:* 耦合性不强,被装饰的类的变化与装饰类的变化无关（说明：其实我们也可以通过让 HeiMaStudent类 继承 Student类 来达到更强大的功能，但是这样做耦合性太高了，        父类（Student类）稍稍做改动，子类也会随着变动，而装饰者模式中的装饰类（HeiMaStudent类）定义好之后，        不会跟着Student类的改动而随着发生改动，没有那么强的耦合性，Student的可选择性也更强，可以选择不同的装饰类        类进行装饰，所以在这里使用装饰者模式！！！）</code></pre></li></ul><p>###21.12_IO流(使用指定的码表读写字符) </p><ul><li>FileReader是使用默认码表读取文件, 如果需要使用指定码表读取, 那么可以使用InputStreamReader(字节流,编码表)，再字符流中使用</li><li>FileWriter是使用默认码表写出文件, 如果需要使用指定码表写出, 那么可以使用OutputStreamWriter(字节流,编码表)，在字符流中使用</li><li><pre><code>BufferedReader br =                                     //高效的用指定的编码表读        new BufferedReader(new InputStreamReader(new FileInputStream(&quot;UTF-8.txt&quot;), &quot;UTF-8&quot;));BufferedWriter bw =                                     //高效的用指定的编码表写        new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;GBK.txt&quot;), &quot;GBK&quot;));int ch;while((ch = br.read()) != -1) {    bw.write(ch);}br.close();bw.close();</code></pre><p>###21.13_IO流(转换流图解)</p></li><li>画图分析转换流</li></ul><p>###21.14_IO流(获取文本上字符出现的次数)</p><ul><li>获取一个文本上每个字符出现的次数,将结果写在times.txt上</li></ul><p>###21.15_IO流(试用版软件)</p><ul><li>当我们下载一个试用版软件,没有购买正版的时候,每执行一次就会提醒我们还有多少次使用机会，用学过的IO流知识,模拟试用版软件,试用10次机会,执行一次就提示一次您还有几次机会,如果次数到了提示请购买正版</li></ul><p>###21.16_File类(递归)</p><ul><li><p>递归的弊端:不能调用次数过多,容易导致栈内存溢出</p><ul><li>递归的好处:不用知道循环次数</li><li></li><li>构造方法是否可以递归调用?</li><li>构造方法不能使用递归调用</li><li></li><li>递归调用是否必须有返回值?</li><li><p>不一定(可以有,也可以没有)</p></li><li><p>5的阶乘    </p></li></ul></li></ul><p>###21.17_File类(练习)</p><ul><li>需求:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.java文件名</li></ul><p>###21.18_IO流(总结)</p><ul><li>1.会用BufferedReader读取GBK码表和UTF-8码表的字符</li><li>2.会用BufferedWriter写出字符到GBK码表和UTF-8码表的文件中</li><li>3.会使用BufferedReader从键盘读取一行</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###21.01_IO流(字符流FileReader)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.字符流是什么&lt;ul&gt;
&lt;li&gt;字符流是可以直接读写字符的IO流&lt;/li&gt;
&lt;li&gt;字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出.  
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="IO流，装饰者模式" scheme="http://zouyip.github.io/tags/IO%E6%B5%81%EF%BC%8C%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>IO字节流</title>
    <link href="http://zouyip.github.io/2017/09/17/day20-IO%E5%AD%97%E8%8A%82%E6%B5%81%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/17/day20-IO字节流笔记/</id>
    <published>2017-09-17T11:25:20.000Z</published>
    <updated>2017-10-26T02:47:33.053Z</updated>
    
    <content type="html"><![CDATA[<p>###20.01_IO流(IO流概述及其分类)</p><ul><li>1.概念<ul><li>IO流用来处理设备之间的数据传输</li><li>Java对数据的操作是通过流的方式</li><li>Java用于操作流的类都在IO包中</li><li>流按流向分为两种：输入流，输出流。</li><li>流按操作类型分为两种：<ul><li>字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的</li><li>字符流 : 字符流只能操作纯字符数据，比较方便。</li></ul></li></ul></li><li>2.IO流常用父类<ul><li>字节流的抽象父类：<ul><li>InputStream </li><li>OutputStream</li></ul></li><li>字符流的抽象父类：<ul><li>Reader </li><li>Writer        </li></ul></li></ul></li><li>3.IO程序书写<ul><li>使用前，导入IO包中的类</li><li>使用时，进行IO异常处理</li><li>使用后，释放资源</li></ul></li></ul><p>###20.02_IO流(FileInputStream)</p><ul><li>read()一次读取一个字节</li><li><pre><code>FileInputStream fis = new FileInputStream(&quot;aaa.txt&quot;);    //创建一个文件输入流对象,并关联aaa.txtint b;                                                    //定义变量,记录每次读到的字节while((b = fis.read()) != -1) {                            //将每次读到的字节赋值给b并判断是否是-1    System.out.println(b);                                //打印每一个字节}fis.close();                                            //关闭流释放资源</code></pre><p>###20.03_IO流(read()方法返回值为什么是int)</p></li><li>read()方法读取的是一个字节,为什么返回是int,而不是byte</li><li><pre><code>因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收,如果11111111会在其前面补上24个0凑足4个字节（int类型数据是占4个字节的）,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型（说明：负数在计算机中用补码表示所以11111111是某个数的补码，&quot;11111111&quot;左边第一位为符号位，0-正数，1-负数。  采用“补码表示法”，结果就是-1。byte定义的bit位数是8位的带符号。</code></pre>###20.04_IO流(FileOutputStream)  * FileOutputStream在创建对象的时候是如果没有这个文件会帮我创建出来<pre><code>* 如果有这个文件就会先将文件清空</code></pre></li><li>write()一次写出一个字节</li><li><pre><code>FileOutputStream fos = new FileOutputStream(&quot;bbb.txt&quot;);    //如果没有bbb.txt,会创建出一个//fos.write(97);                        //虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的一个bytefos.write(98);fos.write(99);fos.close();</code></pre>###20.05_IO流(FileOutputStream追加)</li><li>A:案例演示<ul><li>FileOutputStream的构造方法写出数据如何实现数据的追加写入</li></ul></li><li><pre><code>FileOutputStream fos = new FileOutputStream(&quot;bbb.txt&quot;,true);    //如果没有bbb.txt,会创建出一个//fos.write(97);                        //虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的一个bytefos.write(98);fos.write(99);fos.close();</code></pre></li></ul><p>###20.06_IO流(拷贝图片)</p><ul><li>FileInputStream读取</li><li><p>FileOutputStream写出</p><pre><code>FileInputStream fis = new FileInputStream(&quot;致青春.mp3&quot;);    //创建输入流对象,关联致青春.mp3FileOutputStream fos = new FileOutputStream(&quot;copy.mp3&quot;);//创建输出流对象,关联copy.mp3int b;while((b = fis.read()) != -1) {    fos.write(b);}fis.close();fos.close();</code></pre></li></ul><p>###20.07_IO流(拷贝音频文件画原理图)</p><ul><li>A:案例演示<ul><li>字节流一次读写一个字节复制音频</li></ul></li><li>弊端:效率太低</li></ul><p>###20.08_IO流(字节数组拷贝之available()方法)</p><ul><li>A:案例演示<ul><li>int read(byte[] b):一次读取一个字节数组</li><li>write(byte[] b):一次写出一个字节数组</li><li>available()获取读的文件所有的字节个数</li></ul></li><li><p>弊端:有可能会内存溢出 </p><pre><code>FileInputStream fis = new FileInputStream(&quot;致青春.mp3&quot;);FileOutputStream fos = new FileOutputStream(&quot;copy.mp3&quot;);byte[] arr = new byte[fis.available()];                    //根据文件大小做一个字节数组fis.read(arr);                                            //将文件上的所有字节读取到数组中fos.write(arr);                                            //将数组中的所有字节一次写到了文件上fis.close();fos.close();</code></pre></li></ul><p>###20.09_IO流(定义小数组)</p><ul><li>write(byte[] b)</li><li>write(byte[] b, int off, int len)写出有效的字节个数</li></ul><p>###20.10_IO流(定义小数组的标准格式)</p><ul><li><p>A:案例演示</p><ul><li><p>字节流一次读写一个字节数组复制图片和视频<br>  FileInputStream fis = new FileInputStream(“致青春.mp3”);<br>  FileOutputStream fos = new FileOutputStream(“copy.mp3”);<br>  int len;<br>  byte[] arr = new byte[1024 * 8];                    //自定义字节数组</p><p>  while((len = fis.read(arr)) != -1) {                //如果忘记加arr,返回的就不是读取的字节个数,而是字节的码表值</p><pre><code>//fos.write(arr);fos.write(arr, 0, len);                            //写出字节数组写出有效个字节个数</code></pre><p>  }</p><p>  fis.close();<br>  fos.close();<br>###20.11_IO流(BufferedInputStream和BufferOutputStream拷贝)</p></li></ul></li><li>A:缓冲思想<ul><li>字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，</li><li>这是加入了数组这样的缓冲区效果，java本身在设计的时候，</li><li>也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流<br>（怎么理解装饰（包装）：即原来不够强大进行包装后功能变得更加强大了）</li></ul></li><li>B.BufferedInputStream<ul><li>BufferedInputStream内置了一个缓冲区(数组)</li><li>从BufferedInputStream中读取一个字节时</li><li>BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中, 返回给程序一个</li><li>程序再次读取时, 就不用找文件了, 直接从缓冲区中获取</li><li>直到缓冲区中所有的都被使用过, 才重新从文件中读取8192（1024*8=8KB）个</li></ul></li><li>C.BufferedOutputStream<ul><li>BufferedOutputStream也内置了一个缓冲区(数组)</li><li>程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中</li><li>直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里</li></ul></li><li><p>D.拷贝的代码 </p><pre><code>FileInputStream fis = new FileInputStream(&quot;致青春.mp3&quot;);            //创建文件输入流对象,关联致青春.mp3BufferedInputStream bis = new BufferedInputStream(fis);            //创建缓冲区对fis（文件输入流）装饰FileOutputStream fos = new FileOutputStream(&quot;copy.mp3&quot;);        //创建输出流对象,关联copy.mp3BufferedOutputStream bos = new BufferedOutputStream(fos);        //创建缓冲区对fos（文件输出流）装饰int b;while((b = bis.read()) != -1) {            bos.write(b);}bis.close();                        //只关装饰后的对象即可bos.close();</code></pre></li><li><p>E.小数组的读写和带Buffered的读取哪个更快?</p><ul><li>定义小数组如果是8192个字节大小和Buffered比较的话</li><li>定义小数组会略胜一筹,因为读和写操作的是同一个数组</li><li>而Buffered操作的是两个数组</li></ul></li></ul><p>###20.12_IO流(flush和close方法的区别)</p><ul><li>flush()方法<ul><li>用来刷新缓冲区的,刷新后可以再次写出 </li></ul></li><li>close()方法<ul><li>用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出<br>###20.13_IO流(字节流读写中文) </li></ul></li><li>字节流读取中文的问题<ul><li>字节流在读中文的时候有可能会读到半个中文,造成乱码 </li></ul></li><li>字节流写出中文的问题<ul><li>字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组 </li><li>写出回车换行 write(“\r\n”.getBytes());</li></ul></li></ul><p>###20.14_IO流(流的标准处理异常代码1.6版本及其以前){开发中用的少，面试可能会问，会就可以了）【了解】</p><ul><li><p>try finally嵌套</p><pre><code>FileInputStream fis = null;FileOutputStream fos = null;try {    fis = new FileInputStream(&quot;aaa.txt&quot;);    fos = new FileOutputStream(&quot;bbb.txt&quot;);    int b;    while((b = fis.read()) != -1) {        fos.write(b);    }} finally {    try {        if(fis != null)            fis.close();    }finally {                            //try fianlly的嵌套目的是能关一个尽量关一个        if(fos != null)            fos.close();    }}</code></pre></li></ul><p>###20.15_IO流(流的标准处理异常代码1.7版本)    {开发中用的少，面试可能会问，会就可以了）【了解】</p><ul><li><p>try close</p><pre><code>try(    FileInputStream fis = new FileInputStream(&quot;aaa.txt&quot;);    FileOutputStream fos = new FileOutputStream(&quot;bbb.txt&quot;);    MyClose mc = new MyClose();){    int b;    while((b = fis.read()) != -1) {        fos.write(b);    }}</code></pre></li><li>原理<ul><li>在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉 </li></ul></li></ul><p>###20.16_IO流(图片加密)  *将写出的字节与一个数进行异或,这个数就是密钥,解密的时候再次与这个数异或就可以了。<br>                            eg：b = a ^ 123; a = b ^ 123; 也就是 a = (a ^ 123)^ 123</p><ul><li><p>给图片加密</p><pre><code>BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.jpg&quot;));BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.jpg&quot;));int b;while((b = bis.read()) != -1) {    bos.write(b ^ 123);}bis.close();bos.close();</code></pre></li></ul><p>###20.17_IO流(拷贝文件)</p><ul><li><p>在控制台录入文件的路径,将文件拷贝到当前项目下</p><pre><code>Scanner sc = new Scanner(System.in);System.out.println(&quot;请输入一个文件路径&quot;);String line = sc.nextLine();                //将键盘录入的文件路径存储在line中File file = new File(line);                    //封装成File对象FileInputStream fis = new FileInputStream(file);FileOutputStream fos = new FileOutputStream(file.getName());int len;byte[] arr = new byte[8192];                //定义缓冲区while((len = fis.read(arr)) != -1) {    fos.write(arr,0,len);}fis.close();fos.close();</code></pre></li></ul><p>###20.18_IO流(录入数据拷贝到文件)</p><ul><li><p>将键盘录入的数据拷贝到当前项目下的text.txt文件中,键盘录入数据当遇到quit时就退出</p><pre><code>Scanner sc = new Scanner(System.in);FileOutputStream fos = new FileOutputStream(&quot;text.txt&quot;);System.out.println(&quot;请输入:&quot;);while(true) {    String line = sc.nextLine();    if(&quot;quit&quot;.equals(line))        break;    fos.write(line.getBytes());    fos.write(&quot;\r\n&quot;.getBytes());}fos.close();</code></pre><p>###20.19_day20总结</p></li><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###20.01_IO流(IO流概述及其分类)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.概念&lt;ul&gt;
&lt;li&gt;IO流用来处理设备之间的数据传输&lt;/li&gt;
&lt;li&gt;Java对数据的操作是通过流的方式&lt;/li&gt;
&lt;li&gt;Java用于操作流的类都在IO包中&lt;/li&gt;
&lt;li&gt;流按流向分为两
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="IO流" scheme="http://zouyip.github.io/tags/IO%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>异常、File</title>
    <link href="http://zouyip.github.io/2017/09/16/day19-%E5%BC%82%E5%B8%B8%E3%80%81File-%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/16/day19-异常、File-笔记/</id>
    <published>2017-09-16T11:25:20.000Z</published>
    <updated>2017-10-25T13:06:29.276Z</updated>
    
    <content type="html"><![CDATA[<p>###19.01_异常(异常的概述和分类)</p><ul><li>A:异常的概述<ul><li>异常就是Java程序在运行过程中出现的错误。</li></ul></li><li>B:异常的分类<ul><li>通过API查看Throwable</li><li>Error<ul><li>服务器宕机,数据库崩溃等</li></ul></li><li>Exception<br>C:异常的继承体系</li><li>Throwable<ul><li>Error    </li><li>Exception<ul><li>RuntimeException</li></ul></li></ul></li></ul></li></ul><p>###19.02_异常(JVM默认是如何处理异常的)</p><ul><li>A:JVM默认是如何处理异常的<ul><li>main函数收到这个问题时,有两种处理方式:</li><li>a:自己将该问题处理,然后继续运行</li><li>b:自己没有针对的处理方式,只有交给调用main的jvm来处理</li><li>jvm有一个默认的异常处理机制,就将该异常进行处理.</li><li>并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行</li></ul></li><li>B:案例演示<ul><li>JVM默认如何处理异常</li></ul></li></ul><p>###19.03_异常(try…catch的方式处理异常1)</p><ul><li>A:异常处理的两种方式<ul><li>a:try…catch…finally<ul><li>try catch</li><li>try catch finally</li><li>try finally </li></ul></li><li>b:throws</li></ul></li><li>B:try…catch处理异常的基本格式<ul><li>try…catch…finally</li></ul></li><li>C:案例演示<ul><li>try…catch的方式处理1个异常</li></ul></li></ul><p>###19.04_异常(try…catch的方式处理异常2)</p><ul><li>A:案例演示<ul><li>try…catch的方式处理多个异常</li><li>JDK7以后处理多个异常的方式及注意事项</li></ul></li></ul><p>###19.05_异常(编译期异常和运行期异常的区别)</p><ul><li><p>A:编译期异常和运行期异常的区别</p><ul><li>Java中的异常被分为两大类：编译时异常和运行时异常。</li><li><p>所有的RuntimeException类及其子类的实例被称为运行时异常，其他的异常就是编译时异常</p></li><li><p>编译时异常</p><ul><li>Java程序必须显示处理，否则程序就会发生错误，无法通过编译</li></ul></li><li>运行时异常<ul><li>无需显示处理，也可以和编译时异常一样处理</li></ul></li></ul></li><li>B:案例演示<ul><li>编译期异常和运行期异常的区别</li></ul></li></ul><p>###19.06_异常(Throwable的几个常见方法)</p><ul><li>A:Throwable的几个常见方法<ul><li>a:getMessage()<ul><li>获取异常信息，返回字符串。</li></ul></li><li>b:toString()<ul><li>获取异常类名和异常信息，返回字符串。</li></ul></li><li>c:printStackTrace()<ul><li>获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</li></ul></li></ul></li><li>B:案例演示<ul><li>Throwable的几个常见方法的基本使用</li></ul></li></ul><p>###19.07_异常(throws的方式处理异常)</p><ul><li>A:throws的方式处理异常<ul><li>定义功能方法时，需要把出现的问题暴露出来让调用者去处理。</li><li>那么就通过throws在方法上标识。</li></ul></li><li>B:案例演示<ul><li>举例分别演示编译时异常和运行时异常的抛出</li></ul></li></ul><p>###19.08_异常(throw的概述以及和throws的区别)</p><ul><li>A:throw的概述<ul><li>在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。</li></ul></li><li>B:案例演示    <ul><li>分别演示编译时异常对象和运行时异常对象的抛出</li><li>举例分别演示编译时异常和运行时异常的抛出<pre><code>* 编译时异常的抛出必须对其进行处理* 运行时异常的抛出可以处理也可以不处理</code></pre></li></ul></li><li>C:throws和throw的区别<ul><li>a:throws<ul><li>用在方法声明后面，跟的是异常类名</li><li>可以跟多个异常类名，用逗号隔开</li><li>表示抛出异常，由该方法的调用者来处理</li></ul></li><li>b:throw<ul><li>用在方法体内，跟的是异常对象名</li><li>只能抛出一个异常对象名</li><li>表示抛出异常，由方法体内的语句处理</li></ul></li></ul></li></ul><p>###19.09_异常(finally关键字的特点及作用)</p><ul><li>A:finally的特点<ul><li>被finally控制的语句体一定会执行</li><li>特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))</li></ul></li><li>B:finally的作用<ul><li>用于释放资源，在IO流操作和数据库操作中会见到</li></ul></li><li>C:案例演示<ul><li>finally关键字的特点及作用</li></ul></li></ul><p>###19.10_异常(finally关键字的面试题)</p><ul><li>A:面试题1<ul><li>final,finally和finalize的区别</li></ul></li><li>B:面试题2<ul><li>如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后。</li></ul></li></ul><p>###19.11_异常(自定义异常概述和基本使用)</p><ul><li>A:为什么需要自定义异常<ul><li>举例：人的年龄</li></ul></li><li>B:自定义异常概述<ul><li>继承自Exception</li><li>继承自RuntimeException</li></ul></li><li>C:案例演示<ul><li>自定义异常的基本使用</li></ul></li></ul><p>###19.12_异常(异常的注意事项及如何使用异常处理)</p><ul><li>A:异常注意事项<ul><li>a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)</li><li>b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常</li><li>c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws</li></ul></li><li><p>B:如何使用异常处理</p><ul><li>原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws</li><li><p>区别:</p><ul><li>后续程序需要继续运行就try</li><li>后续程序不需要继续运行就throws</li></ul></li><li><p>如果JDK没有提供对应的异常，需要自定义异常。</p></li></ul></li></ul><p>###19.13_异常(练习)</p><ul><li>键盘录入一个int类型的整数,对其求二进制表现形式<ul><li>如果录入的整数过大,给予提示,录入的整数过大请重新录入一个整数BigInteger</li><li>如果录入的是小数,给予提示,录入的是小数,请重新录入一个整数</li><li>如果录入的是其他字符,给予提示,录入的是非法字符,请重新录入一个整数</li></ul></li></ul><p>###19.14_File类(File类的概述和构造方法)</p><ul><li>A:File类的概述<ul><li>File更应该叫做一个路径<ul><li>文件路径或者文件夹路径  </li><li>路径分为绝对路径和相对路径</li><li>绝对路径是一个固定的路径,从盘符开始</li><li>相对路径相对于某个位置,在eclipse下是指当前项目下,在dos下</li></ul></li><li>查看API指的是当前路径</li><li>文件（路径名）或目录路径名的抽象表示形式</li></ul></li><li>B:构造方法<ul><li>File(String pathname)：根据一个路径得到File对象</li><li>File(String parent, String child):根据一个目录和一个子文件/目录得到File对象</li><li>File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象</li></ul></li><li>C:案例演示<ul><li>File类的构造方法</li></ul></li></ul><p>###19.15_File类(File类的创建功能)</p><ul><li>A:创建功能<ul><li>public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了</li><li>public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了</li><li>public boolean mkdirs():创建多级文件夹。</li></ul></li><li><p>B:案例演示</p><ul><li><p>File类的创建功能</p></li><li><p>注意事项：</p><ul><li>如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。</li></ul></li></ul></li></ul><p>###19.16_File类(File类的重命名和删除功能)</p><ul><li>A:重命名和删除功能<ul><li>public boolean renameTo(File dest):把文件重命名为指定的文件路径</li><li>public boolean delete():删除文件或者文件夹</li></ul></li><li>B:重命名注意事项<ul><li>如果路径名相同，就是改名。</li><li>如果路径名不同，就是改名并剪切。</li></ul></li><li>C:删除注意事项：<ul><li>Java中的删除不走回收站。</li><li>要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹</li></ul></li></ul><p>###19.17_File类(File类的判断功能)</p><ul><li>A:判断功能<ul><li>public boolean isDirectory():判断是否是目录</li><li>public boolean isFile():判断是否是文件</li><li>public boolean exists():判断是否存在</li><li>public boolean canRead():判断是否可读</li><li>public boolean canWrite():判断是否可写</li><li>public boolean isHidden():判断是否隐藏</li></ul></li><li>B:案例演示<ul><li>File类的判断功能</li></ul></li></ul><p>###19.18_File类(File类的获取功能)</p><ul><li>A:获取功能<ul><li>public String getAbsolutePath()：获取绝对路径</li><li>public String getPath():获取路径（获取的是创建对象时构造方法里的路径）</li><li>public String getName():获取名称 （获取文件或者文件夹的名字）</li><li>public long length():获取长度。字节数</li><li>public long lastModified():获取最后一次的修改时间，毫秒值</li><li>public String[] list():获取指定目录下的所有文件或者文件夹的名称数组 （获取的是文件名）</li><li>public File[] listFiles():获取指定目录下的所有文件或者文件夹的 File数组 （注意：获取的的File对象，可以拿来操作）</li></ul></li><li>B:案例演示<ul><li>File类的获取功能</li></ul></li></ul><p>###19.19_File类(输出指定目录下指定后缀的文件名)</p><ul><li>A:案例演示<ul><li>需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称</li></ul></li></ul><p>###19.20_File类(文件名称过滤器的概述及使用)</p><ul><li>A:文件名称过滤器的概述<ul><li>public String[] list(FilenameFilter filter)</li><li>public File[] listFiles(FileFilter filter)</li></ul></li><li>B:文件名称过滤器的使用<ul><li>需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称</li></ul></li><li>C:源码分析<ul><li>带文件名称过滤器的list()方法的源码</li></ul></li></ul><p>###19.21_File类(递归)</p><ul><li>5的阶乘        </li></ul><p>###19.22_day19总结<br>把今天的知识点总结一遍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###19.01_异常(异常的概述和分类)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:异常的概述&lt;ul&gt;
&lt;li&gt;异常就是Java程序在运行过程中出现的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:异常的分类&lt;ul&gt;
&lt;li&gt;通过API查看Throwable&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="exception" scheme="http://zouyip.github.io/tags/exception/"/>
    
      <category term="File" scheme="http://zouyip.github.io/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>Map</title>
    <link href="http://zouyip.github.io/2017/09/14/day18-Map%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/14/day18-Map笔记/</id>
    <published>2017-09-14T07:25:20.000Z</published>
    <updated>2017-10-25T03:52:52.651Z</updated>
    
    <content type="html"><![CDATA[<p>###18.01_集合框架(Map集合概述和特点)</p><ul><li>A:Map接口概述<ul><li>查看API可以知道：<ul><li>将键映射到值的对象</li><li>一个映射不能包含重复的键</li><li>每个键最多只能映射到一个值</li></ul></li></ul></li><li>B:Map接口和Collection接口的不同<ul><li>Map是双列的,Collection是单列的</li><li>Map的键唯一,Collection的子体系Set是唯一的</li><li>Map集合的数据结构只针对键有效，跟值无关;Collection集合的数据结构是针对元素有效</li></ul></li></ul><p>###18.02_集合框架(Map集合的功能概述)</p><ul><li>A:Map集合的功能概述<ul><li>a:添加功能<ul><li>V put(K key,V value):添加元素。<ul><li>如果键是第一次存储，就直接存储元素，返回null</li><li>如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值</li></ul></li></ul></li><li>b:删除功能<ul><li>void clear():移除所有的键值对元素</li><li>V remove(Object key)：根据键删除键值对元素，并把值返回</li></ul></li><li>c:判断功能<ul><li>boolean containsKey(Object key)：判断集合是否包含指定的键</li><li>boolean containsValue(Object value):判断集合是否包含指定的值</li><li>boolean isEmpty()：判断集合是否为空</li></ul></li><li>d:获取功能<ul><li>Set<map.entry<k,v>&gt; entrySet():</map.entry<k,v></li><li>V get(Object key):根据键获取值</li><li>Set<k> keySet():获取集合中所有键的集合</k></li><li>Collection<v> values():获取集合中所有值的集合</v></li></ul></li><li>e:长度功能<ul><li>int size()：返回集合中的键值对的个数</li></ul></li></ul></li></ul><p>###18.03_集合框架(Map集合的遍历之键找值)</p><ul><li>A:键找值思路：<ul><li>获取所有键的集合</li><li>遍历键的集合，获取到每一个键</li><li>根据键找值</li></ul></li><li><p>B:案例演示</p><ul><li><p>Map集合的遍历之键找值</p><pre><code>HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;();hm.put(&quot;张三&quot;, 23);hm.put(&quot;李四&quot;, 24);hm.put(&quot;王五&quot;, 25);hm.put(&quot;赵六&quot;, 26);/*Set&lt;String&gt; keySet = hm.keySet();            //获取集合中所有的键Iterator&lt;String&gt; it = keySet.iterator();    //获取迭代器while(it.hasNext()) {                        //判断单列集合中是否有元素    String key = it.next();                    //获取集合中的每一个元素,其实就是双列集合中的键    Integer value = hm.get(key);            //根据键获取值    System.out.println(key + &quot;=&quot; + value);    //打印键值对}*/for(String key : hm.keySet()) {                //增强for循环迭代双列集合第一种方式    System.out.println(key + &quot;=&quot; + hm.get(key));}</code></pre></li></ul></li></ul><p>###18.04_集合框架(Map集合的遍历之键值对对象找键和值)</p><ul><li>A:键值对对象找键和值思路：<ul><li>获取所有键值对对象的集合</li><li>遍历键值对对象的集合，获取到每一个键值对对象</li><li>根据键值对对象找键和值</li></ul></li><li><p>B:案例演示</p><ul><li><p>Map集合的遍历之键值对对象找键和值</p><pre><code>HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;();hm.put(&quot;张三&quot;, 23);hm.put(&quot;李四&quot;, 24);hm.put(&quot;王五&quot;, 25);hm.put(&quot;赵六&quot;, 26);/*Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = hm.entrySet();    //获取所有的键值对象的集合Iterator&lt;Entry&lt;String, Integer&gt;&gt; it = entrySet.iterator();//获取迭代器while(it.hasNext()) {    Entry&lt;String, Integer&gt; en = it.next();                //获取键值对对象    String key = en.getKey();                                //根据键值对对象获取键    Integer value = en.getValue();                            //根据键值对对象获取值    System.out.println(key + &quot;=&quot; + value);}*/for(Entry&lt;String,Integer&gt; en : hm.entrySet()) {    System.out.println(en.getKey() + &quot;=&quot; + en.getValue());}</code></pre></li></ul></li></ul><p>C:源码分析</p><p>###18.05_集合框架(HashMap集合键是Student值是String的案例)</p><ul><li>A:案例演示<ul><li>HashMap集合键是Student值是String的案例</li></ul></li></ul><p>###18.06_集合框架(LinkedHashMap的概述和使用)</p><ul><li>A:案例演示<ul><li>LinkedHashMap的特点<ul><li>底层是链表实现的，可以保证怎么存就怎么取</li></ul></li></ul></li></ul><p>###18.07_集合框架(TreeMap集合键是Student值是String的案例)</p><ul><li>A:案例演示<ul><li>TreeMap集合：键是Student，值是String的案例</li></ul></li></ul><p>###18.08_集合框架(统计字符串中每个字符出现的次数)</p><ul><li><p>A:案例演示</p><ul><li><p>需求：统计字符串中每个字符出现的次数</p><pre><code>String str = &quot;aaaabbbcccccccccc&quot;;char[] arr = str.toCharArray();                        //将字符串转换成字符数组HashMap&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;();    //创建双列集合存储键和值for(char c : arr) {                                    //遍历字符数组    /*if(!hm.containsKey(c)) {                        //如果不包含这个键        hm.put(c, 1);                                //就将键和值为1添加    }else {                                            //如果包含这个键        hm.put(c, hm.get(c) + 1);                    //就将键和值再加1添加进来    }    //hm.put(c, !hm.containsKey(c) ? 1 : hm.get(c) + 1);    Integer i = !hm.containsKey(c) ? hm.put(c, 1) : hm.put(c, hm.get(c) + 1);            }for (Character key : hm.keySet()) {                    //遍历双列集合    System.out.println(key + &quot;=&quot; + hm.get(key));}</code></pre></li></ul></li></ul><p>###18.09_集合框架(集合嵌套之HashMap嵌套HashMap)</p><ul><li>A:案例演示<ul><li>集合嵌套之HashMap嵌套HashMap</li></ul></li></ul><p>###18.10_集合框架(HashMap和Hashtable的区别)</p><ul><li>A:面试题<ul><li>HashMap和Hashtable的区别<ul><li>Hashtable是JDK1.0版本出现的,是线程安全的,效率低,HashMap是JDK1.2版本出现的,是线程不安全的,效率高</li><li>Hashtable不可以存储null键和null值,HashMap可以存储null键和null值</li></ul></li></ul></li><li>B:案例演示    <ul><li>HashMap和Hashtable的区别</li></ul></li></ul><p>###18.11_集合框架(Collections工具类的概述和常见方法讲解)</p><ul><li>A:Collections类概述<ul><li>针对集合操作 的工具类</li></ul></li><li>B:Collections成员方法</li><li><pre><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key)public static &lt;T&gt; T max(Collection&lt;?&gt; coll)public static void reverse(List&lt;?&gt; list)public static void shuffle(List&lt;?&gt; list)</code></pre></li></ul><p>###18.12_集合框架(模拟斗地主洗牌和发牌)</p><ul><li><p>A:案例演示</p><ul><li><p>模拟斗地主洗牌和发牌，牌没有排序</p><pre><code>//买一副扑克String[] num = {&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;};String[] color = {&quot;方片&quot;,&quot;梅花&quot;,&quot;红桃&quot;,&quot;黑桃&quot;};ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;();for(String s1 : color) {    for(String s2 : num) {        poker.add(s1.concat(s2));    }}poker.add(&quot;小王&quot;);poker.add(&quot;大王&quot;);//洗牌Collections.shuffle(poker);//发牌ArrayList&lt;String&gt; gaojin = new ArrayList&lt;&gt;();ArrayList&lt;String&gt; longwu = new ArrayList&lt;&gt;();ArrayList&lt;String&gt; me = new ArrayList&lt;&gt;();ArrayList&lt;String&gt; dipai = new ArrayList&lt;&gt;();for(int i = 0; i &lt; poker.size(); i++) {    if(i &gt;= poker.size() - 3) {        dipai.add(poker.get(i));    }else if(i % 3 == 0) {        gaojin.add(poker.get(i));    }else if(i % 3 == 1) {        longwu.add(poker.get(i));    }else {        me.add(poker.get(i));    }}//看牌System.out.println(gaojin);System.out.println(longwu);System.out.println(me);System.out.println(dipai);</code></pre></li></ul></li></ul><p>###18.13_集合框架(模拟斗地主洗牌和发牌并对牌进行排序的原理图解)</p><ul><li>A:画图演示<ul><li>画图说明排序原理</li></ul></li></ul><p>###18.14_集合框架(模拟斗地主洗牌和发牌并对牌进行排序的代码实现)</p><ul><li>A:案例演示<ul><li>模拟斗地主洗牌和发牌并对牌进行排序的代码实现</li></ul></li><li><pre><code>    //买一副牌    String[] num = {&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;};    String[] color = {&quot;方片&quot;,&quot;梅花&quot;,&quot;红桃&quot;,&quot;黑桃&quot;};    HashMap&lt;Integer, String&gt; hm = new HashMap&lt;&gt;();            //存储索引和扑克牌    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();            //存储索引    int index = 0;                                            //索引的开始值    for(String s1 : num) {        for(String s2 : color) {            hm.put(index, s2.concat(s1));                    //将索引和扑克牌添加到HashMap中            list.add(index);                                //将索引添加到ArrayList集合中            index++;                ////自动装箱了，所以会改变index的值        }    }    hm.put(index, &quot;小王&quot;);    list.add(index);    index++;    hm.put(index, &quot;大王&quot;);    list.add(index);    //洗牌    Collections.shuffle(list);    //发牌    TreeSet&lt;Integer&gt; gaojin = new TreeSet&lt;&gt;();    TreeSet&lt;Integer&gt; longwu = new TreeSet&lt;&gt;();    TreeSet&lt;Integer&gt; me = new TreeSet&lt;&gt;();    TreeSet&lt;Integer&gt; dipai = new TreeSet&lt;&gt;();    for(int i = 0; i &lt; list.size(); i++) {        if(i &gt;= list.size() - 3) {            dipai.add(list.get(i));                         //将list集合中的索引添加到TreeSet集合中会自动排序        }else if(i % 3 == 0) {            gaojin.add(list.get(i));        }else if(i % 3 == 1) {            longwu.add(list.get(i));        }else {            me.add(list.get(i));        }    }    //看牌    lookPoker(&quot;高进&quot;, gaojin, hm);    lookPoker(&quot;龙五&quot;, longwu, hm);    lookPoker(&quot;冯佳&quot;, me, hm);    lookPoker(&quot;底牌&quot;, dipai, hm);}public static void lookPoker(String name,TreeSet&lt;Integer&gt; ts,HashMap&lt;Integer, String&gt; hm) {    System.out.print(name + &quot;的牌是:&quot;);    for (Integer index : ts) {        System.out.print(hm.get(index) + &quot; &quot;);    }    System.out.println();}</code></pre><p>###18.15_集合框架(泛型固定下边界)</p></li><li>? super E</li></ul><p>###18.16_day18总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###18.01_集合框架(Map集合概述和特点)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:Map接口概述&lt;ul&gt;
&lt;li&gt;查看API可以知道：&lt;ul&gt;
&lt;li&gt;将键映射到值的对象&lt;/li&gt;
&lt;li&gt;一个映射不能包含重复的键&lt;/li&gt;
&lt;li&gt;每个键最多只能映射到一个值&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Map" scheme="http://zouyip.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Set</title>
    <link href="http://zouyip.github.io/2017/09/12/day17-Set%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/12/day17-Set笔记/</id>
    <published>2017-09-12T11:25:20.000Z</published>
    <updated>2017-10-25T01:50:29.982Z</updated>
    
    <content type="html"><![CDATA[<p>###17.01_集合框架(HashSet存储字符串并遍历)</p><ul><li>A:Set集合概述及特点  Set集合,无索引,不可以重复,无序(存取不一致)<ul><li>通过API查看即可</li></ul></li><li><p>B:案例演示</p><ul><li>HashSet存储字符串并遍历   </li><li><pre><code> HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();boolean b1 = hs.add(&quot;a&quot;);boolean b2 = hs.add(&quot;a&quot;);            //当存储不成功的时候,返回falseSystem.out.println(b1);System.out.println(b2);for(String s : hs) {    System.out.println(s);}</code></pre></li></ul></li></ul><p>###17.02_集合框架(HashSet存储自定义对象保证元素唯一性)        <em>HashSet的继承体系中有重写toString方法                                                              </em>只要能用迭代器迭代的,就可以使用增强for循环遍历</p><ul><li><p>A:案例演示</p><ul><li><p>存储 自定义对象 ，并保证元素唯一性。</p><pre><code>HashSet&lt;Person&gt; hs = new HashSet&lt;&gt;();hs.add(new Person(&quot;张三&quot;, 23));hs.add(new Person(&quot;张三&quot;, 23));hs.add(new Person(&quot;李四&quot;, 23));hs.add(new Person(&quot;李四&quot;, 23));hs.add(new Person(&quot;王五&quot;, 23));hs.add(new Person(&quot;赵六&quot;, 23));</code></pre></li></ul></li><li>注意：通过重写hashCode()和equals()方法来保证HashSet存储自定义对象元素的唯一性！！！<pre><code>如果不重写的话，那么new出来的是不同的对象（地址值不同），所以会将元素值相同的对象视为不同的对象存储在HashSet集合中。要使HashSet存储自定义对象保证元素唯一性，则需要通过重写hashCode()和equals()方法来保证HashSet存储自定义对象元素的唯一性！！！重写hashCode（）方法返回同一个值（值相同时），才会调用重写的equals（）方法。</code></pre>###17.03_集合框架(HashSet存储自定义对象保证元素唯一性图解及代码优化)</li><li>A:画图演示<ul><li>画图说明比较过程</li></ul></li><li>B:代码优化<ul><li>为了减少比较，优化hashCode()代码写法。</li><li>最终版就是自动生成即可。</li></ul></li></ul><p>###17.04_集合框架(HashSet如何保证元素唯一性的原理)</p><ul><li>1.HashSet原理<ul><li>我们使用Set集合都是需要去掉重复元素的, 如果在存储的时候逐个equals()比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用equals()方法的次数</li><li>当HashSet调用add()方法存储对象的时候, 先调用对象的hashCode()方法得到一个哈希值, 然后在集合中查找是否有哈希值相同的对象<ul><li>如果没有哈希值相同的对象就直接存入集合</li><li>如果有哈希值相同的对象, 就和哈希值相同的对象逐个进行equals()比较,比较结果为false就存入, true则不存</li></ul></li></ul></li><li>2.将自定义类的对象存入HashSet去重复<ul><li>类中必须重写hashCode()和equals()方法  （注意：如果不重写的话就不能达到去重的效果，可能出现重复的元素）</li><li>hashCode(): 属性相同的对象返回值必须相同, 属性不同的返回值尽量不同(提高效率)</li><li>equals(): 属性相同返回true, 属性不同返回false,返回false的时候存储</li></ul></li></ul><p>###17.05_集合框架(LinkedHashSet的概述和使用)</p><ul><li>LinkedHashSet<ul><li>底层是链表实现的,是set集合中 唯一一个能保证怎么存就怎么取的集合对象</li><li>因为是HashSet的子类,所以也是保证元素唯一的,与HashSet的原理一样</li></ul></li><li>A:LinkedHashSet的特点</li><li>B:案例演示<ul><li>LinkedHashSet的特点<ul><li>可以保证怎么存就怎么取 </li></ul></li></ul></li></ul><p>###17.06_集合框架(产生10个1-20之间的随机数要求随机数不能重复)</p><ul><li><p>A:案例演示</p><ul><li>需求：编写一个程序，获取10个1至20的随机数，要求随机数不能重复。并把最终的随机数输出到控制台。</li><li><pre><code>HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();        //创建集合对象Random r = new Random();                    //创建随机数对象while(hs.size() &lt; 10) {    int num = r.nextInt(20) + 1;            //生成1到20的随机数    hs.add(num);}for (Integer integer : hs) {                //遍历集合    System.out.println(integer);            //打印每一个元素}</code></pre></li></ul></li></ul><p>###17.07_集合框架(练习)</p><ul><li><p>使用Scanner从键盘读取一行输入,去掉其中重复字符, 打印出不同的那些字符</p><ul><li><p>aaaabbbcccddd</p><pre><code>Scanner sc = new Scanner(System.in);            //创建键盘录入对象System.out.println(&quot;请输入一行字符串:&quot;);String line = sc.nextLine();                    //将键盘录入的字符串存储在line中char[] arr = line.toCharArray();                //将字符串转换成字符数组HashSet&lt;Character&gt; hs = new HashSet&lt;&gt;();        //创建HashSet集合对象for(char c : arr) {                                //遍历字符数组    hs.add(c);                                    //将字符数组中的字符添加到集合中}for (Character ch : hs) {                        //遍历集合    System.out.println(ch);}</code></pre><p>###17.08_集合框架(练习)</p></li></ul></li><li>将集合中的重复元素去掉</li><li><pre><code>public static void main(String[] args) {    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add(&quot;a&quot;);    list.add(&quot;a&quot;);    list.add(&quot;a&quot;);    list.add(&quot;b&quot;);    list.add(&quot;b&quot;);    list.add(&quot;b&quot;);    list.add(&quot;b&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    System.out.println(list);    System.out.println(&quot;去除重复后:&quot;);    getSingle(list);    System.out.println(list);}/* * 将集合中的重复元素去掉 * 1,void * 2,List&lt;String&gt; list */public static void getSingle(List&lt;String&gt; list) {    LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;&gt;();    lhs.addAll(list);                                    //将list集合中的所有元素添加到lhs    list.clear();                                        //清空原集合    list.addAll(lhs);                                    //将去除重复的元素添回到list中}</code></pre></li></ul><p>###17.09_集合框架(TreeSet存储Integer类型的元素并遍历)<em>**</em>TreeSet的底层数据结构是二叉树，</p><ul><li>A:案例演示<ul><li>TreeSet存储Integer类型的元素并遍历</li></ul></li></ul><p>###17.10_集合框架(TreeSet存储自定义对象)</p><ul><li>A:案例演示<ul><li>存储Person对象</li></ul></li></ul><p>###17.11_集合框架(TreeSet保证元素唯一和自然排序的原理（按二叉树的读取方式读取进行排序）和图解)<br>                    根据compareTo方法的返回值来实现的。</p><ul><li>A:画图演示<ul><li>TreeSet保证元素唯一和自然排序的原理和图解</li></ul></li></ul><p>###17.12_集合框架(TreeSet存储自定义对象并遍历练习1)</p><ul><li>A:案例演示<ul><li>TreeSet存储自定义对象并遍历练习1(按照姓名排序)</li></ul></li></ul><p>###17.13_集合框架(TreeSet存储自定义对象并遍历练习2)</p><ul><li>A:案例演示<ul><li>TreeSet存储自定义对象并遍历练习2(按照姓名的长度排序)</li></ul></li></ul><p>###17.14_集合框架(TreeSet保证元素唯一和比较器排序的原理及代码实现)</p><ul><li>A:案例演示<ul><li>TreeSet保证元素唯一和比较器排序的原理及代码实现</li></ul></li></ul><p>###17.15_集合框架(TreeSet原理)</p><ul><li>1.特点<ul><li>TreeSet是用来排序的, 可以指定一个顺序, 对象存入之后会按照指定的顺序排列</li></ul></li><li>2.使用方式<ul><li>a.自然顺序(Comparable)<ul><li>TreeSet类的add()方法中会把存入的对象提升为Comparable类型</li><li>调用对象的compareTo()方法和集合中的对象比较</li><li>根据compareTo()方法返回的结果进行存储</li></ul></li><li>b.比较器顺序(Comparator)<ul><li>创建TreeSet的时候可以制定 一个Comparator</li><li>如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序</li><li>add()方法内部会自动调用Comparator接口中compare()方法排序</li><li>调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数</li></ul></li><li>c.两种方式的区别<ul><li>TreeSet构造函数什么都不传, 默认按照类中Comparable的顺序(没有就报错ClassCastException)</li><li>TreeSet如果传入Comparator, 就优先按照Comparator</li></ul></li></ul></li></ul><p>###17.16_集合框架(练习)</p><ul><li><p>在一个集合中存储了无序并且重复的字符串,定义一个方法,让其有序(字典顺序),而且还不能去除重复</p><pre><code>public static void main(String[] args) {    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add(&quot;ccc&quot;);    list.add(&quot;ccc&quot;);    list.add(&quot;aaa&quot;);    list.add(&quot;aaa&quot;);    list.add(&quot;bbb&quot;);    list.add(&quot;ddd&quot;);    list.add(&quot;ddd&quot;);    sort(list);    System.out.println(list);}/* * 对集合中的元素排序,并保留重复 * 1,void * 2,List&lt;String&gt; list */public static void sort(List&lt;String&gt; list) {    TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() {        //定义比较器(new Comparator(){}是Comparator的子类对象)        @Override        public int compare(String s1, String s2) {                        //重写compare方法            int num = s1.compareTo(s2);                                    //比较内容            return num == 0 ? 1 : num;                                    //如果内容一样返回一个不为0的数字即可        }    });    ts.addAll(list);                                                    //将list集合中的所有元素添加到ts中    list.clear();                                                        //清空list    list.addAll(ts);                                                    //将ts中排序并保留重复的结果在添加到list中}</code></pre></li></ul><p>###17.17_集合框架(练习)</p><ul><li><p>从键盘接收一个字符串, 程序对其中所有字符进行排序,例如键盘输入: helloitcast程序打印:acehillostt</p><pre><code>Scanner sc = new Scanner(System.in);            //创建键盘录入对象System.out.println(&quot;请输入一行字符串:&quot;);String line = sc.nextLine();                    //将键盘录入的字符串存储在line中char[] arr = line.toCharArray();                //将字符串转换成字符数组TreeSet&lt;Character&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Character&gt;() {    @Override    public int compare(Character c1, Character c2) {        //int num = c1.compareTo(c2);        int num = c1 - c2;                    //自动拆箱        return num == 0 ? 1 : num;    }});for(char c : arr) {    ts.add(c);}for(Character ch : ts) {    System.out.print(ch);}</code></pre><p>###17.18_集合框架(练习)</p></li><li><p>程序启动后, 可以从键盘输入接收多个整数, 直到输入quit时结束输入. 把所有输入的整数倒序排列打印.</p><pre><code>Scanner sc = new Scanner(System.in);        //创建键盘录入对象System.out.println(&quot;请输入:&quot;);TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Integer&gt;() {//将比较器传给TreeSet的构造方法    @Override    public int compare(Integer i1, Integer i2) {        //int num = i2 - i1;                    //自动拆箱        int num = i2.compareTo(i1);        return num == 0 ? 1 : num;    }});while(true) {    String line = sc.nextLine();            //将键盘录入的字符串存储在line中    if(&quot;quit&quot;.equals(line))                    //如果字符串常量和变量比较,常量放前面,这样不会出现空指针异常,变量里面可能存储null        break;    try {        int num = Integer.parseInt(line);        //将数字字符串转换成数字        ts.add(num);    } catch (Exception e) {        System.out.println(&quot;您录入的数据有误,请输入一个整数&quot;);    }}for (Integer i : ts) {                        //遍历TreeSet集合    System.out.println(i);}</code></pre><p>###17.19_集合框架(键盘录入学生信息按照总分排序后输出在控制台)</p></li><li><p>A:案例演示</p><ul><li><p>需求：键盘录入5个学生信息(姓名,语文成绩,数学成绩,英语成绩),按照总分从高到低输出到控制台。</p><pre><code>Scanner sc = new Scanner(System.in);System.out.println(&quot;请输入5个学生成绩格式是:(姓名,语文成绩,数学成绩,英语成绩)&quot;);TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() {    @Override    public int compare(Student s1, Student s2) {        int num = s2.getSum() - s1.getSum();            //根据学生的总成绩降序排列        return num == 0 ? 1 : num;    }});while(ts.size() &lt; 5) {    String line = sc.nextLine();    try {        String[] arr = line.split(&quot;,&quot;);        int chinese = Integer.parseInt(arr[1]);                //转换语文成绩        int math = Integer.parseInt(arr[2]);                //转换数学成绩        int english = Integer.parseInt(arr[3]);                //转换英语成绩        ts.add(new Student(arr[0], chinese, math, english));    } catch (Exception e) {        System.out.println(&quot;录入格式有误,输入5个学生成绩格式是:(姓名,语文成绩,数学成绩,英语成绩&quot;);    }}System.out.println(&quot;排序后的学生成绩是:&quot;);for (Student s : ts) {    System.out.println(s);}</code></pre></li></ul></li></ul><p>###17.20_day17总结</p><ul><li>1.List<ul><li>a.普通for循环, 使用get()逐个获取</li><li>b.调用iterator()方法得到Iterator, 使用hasNext()和next()方法</li><li>c.增强for循环, 只要可以使用Iterator的类都可以用</li><li>d.Vector集合可以使用Enumeration的hasMoreElements()和nextElement()方法</li></ul></li><li>2.Set<ul><li>a.调用iterator()方法得到Iterator, 使用hasNext()和next()方法</li><li>b.增强for循环, 只要可以使用Iterator的类都可以用</li></ul></li><li><p>3.普通for循环,迭代器,增强for循环是否可以在遍历的过程中删除 </p><p>  哈希表，是一种数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。<br>  这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>二、Hashtable、HashMap、ConcurrentHashMap、LinkedHashMap、TreeMap区别</p></li></ul><p>　　Hashtable是一个包含单向链表的二维数组，其数据结构的数组中是Entry<k,v>存储，entry对象。Hashtable有洁癖，<br>    不允许存入其中的key或者value为null。Hashtable是线程安全的，所有的方法均用synchronized修饰，这样在任一时刻，<br>    只有一个线程可以写Hashtable，因此，对于频繁写操作的业务逻辑，诸如写excel表等时候，速度会非常慢。</k,v></p><p>　　HashMap是最常用的Map型数据结构，它根据键的hashCode()值存储数据。HashMap允许一个key为null,允许多个value为空，<br>    HashMap不支持线程的同步，即可能会出现在同一时刻有多个线程同时写HashMap,会产生数据的不一致。如果在修改代码的过程中，<br>    需要给HashMap限制为线程同步的，可以采用Collections.synchronizedMap(map);方法使得HashMap可以同步。</p><p>　　ConcurrentHashMap是基于这样的考虑：降低锁的粒度。在Hashtable中的关键字是使用synchronized基于整张表结构的，锁的粒度太大，<br>    它每次通过锁住整张表让线程独占，来保证安全性。</p><p>　　LinkedHashMap保存了记录的插入顺序，在使用Iterator遍历LinkedHashMap的时候，先得到的记录肯定是先插入的。<br>    在遍历的时候会比HashMap慢，因为HashMap是以O(1)来设计存取的。并且LinkedHashMap继承自HashMap，拥有它的全部特性。</p><p>　　TreeMap是基于红黑树实现的，它是一种有序的存储结构，并且程序员可以自己定义排序器。TreeMap默认会按存入的键值key来排序，<br>    默认是按升序排序，当然也可以指定排序的比较器。TreeMap同样有洁癖，不允许存入null值。使用Iterator遍历出来的TreeMap往往是有序的。</p><p>　　总结：常用HashMap，允许null插入；有两个子类：ConcurrentHashMap和LinkedHashMap。前者用来弥补线程安全，后者用来弥补有序。<br>    此外还有Hashtable和TreeMap。虽然CouncurrentHashMap性能明显优于Hashtable，但是并不能完全取代Hashtable，<br>    因为遍历ConcurrentHashMap的迭代器是弱一致的。TreeMap数据结构则可以帮助我们得到一个有序的结果，适用于需要输出排序结果的场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###17.01_集合框架(HashSet存储字符串并遍历)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:Set集合概述及特点  Set集合,无索引,不可以重复,无序(存取不一致)&lt;ul&gt;
&lt;li&gt;通过API查看即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B:案例演示&lt;/p&gt;

      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Set" scheme="http://zouyip.github.io/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList，泛型</title>
    <link href="http://zouyip.github.io/2017/09/12/day16-ArrayList%E3%80%81%E6%B3%9B%E5%9E%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/12/day16-ArrayList、泛型笔记/</id>
    <published>2017-09-12T08:53:30.000Z</published>
    <updated>2017-10-25T01:49:34.123Z</updated>
    
    <content type="html"><![CDATA[<p>###16.01_集合框架(去除ArrayList中重复字符串元素方式)(掌握)</p><ul><li><p>A:案例演示</p><ul><li>需求：ArrayList去除集合中字符串的重复值(字符串的内容相同)</li><li><p>思路：创建新集合方式</p><pre><code>/** *  A:案例演示 * 需求：ArrayList去除集合中字符串的重复值(字符串的内容相同) * 思路：创建新集合方式 */public static void main(String[] args) {    ArrayList list = new ArrayList();    list.add(&quot;a&quot;);    list.add(&quot;a&quot;);    list.add(&quot;b&quot;);    list.add(&quot;b&quot;);    list.add(&quot;b&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    list.add(&quot;c&quot;);    System.out.println(list);    ArrayList newList = getSingle(list);    System.out.println(newList);}/* * 去除重复 * 1,返回ArrayList * 2,参数列表ArrayList */public static ArrayList getSingle(ArrayList list) {    ArrayList newList = new ArrayList();            //创建一个新集合    Iterator it = list.iterator();                    //获取迭代器    while(it.hasNext()) {                            //判断老集合中是否有元素        String temp = (String)it.next();            //将每一个元素临时记录住        if(!newList.contains(temp)) {                //如果新集合中不包含该元素            newList.add(temp);                        //将该元素添加到新集合中        }    }    return newList;                                    //将新集合返回}</code></pre><p>###16.02_集合框架(去除ArrayList中重复自定义对象元素)(掌握)</p></li></ul></li><li>A:案例演示<ul><li>需求：ArrayList去除集合中自定义对象元素的重复值(对象的成员变量值相同)</li></ul></li><li>B:注意事项<ul><li>重写equals()方法<br>  contains方法判断是否包含,底层依赖的是equals方法.<br>  remove方法判断是否删除,底层依赖的是equals方法.</li></ul></li></ul><p>###16.03_集合框架(LinkedList的特有功能)(掌握)</p><ul><li>A:LinkedList类概述</li><li><p>B:LinkedList类特有功能</p><ul><li>public void addFirst(E e)及addLast(E e)    在头部添加元素 或在尾部添加元素 </li><li>public E getFirst()及getLast()</li><li>public E removeFirst()及public E removeLast()</li><li><p>public E get(int index);</p><p>LinkedList：</p><p>  *特有方法：　　</p><pre><code>*addFirst();在头部添加元素      addLast();在尾部添加元素*getFirst(); getLast(); 获取元素但不删除元素。如果集合中没有元素，会出现NoSuchElementException*removeFirst();   removeLast(); 获取元素但是删除元素。如果集合中没有元素，会出现NoSuchElementException*在JDK1.6出现了替代方法*offerFirst(); offerLast();*peekFirst(); peekLast(); 获取元素，但是元素不被删除。如果集合中没有元素，会返回null*pollFirst(); pollLast(); 获取元素，但是元素被删除。如果集合中没有元素，会返回null</code></pre></li></ul></li></ul><p>###16.04_集合框架(栈和队列数据结构)(掌握)</p><ul><li>栈<ul><li>先进后出 </li></ul></li><li>队列<ul><li>先进先出</li></ul></li></ul><p>###16.05_集合框架(用LinkedList模拟栈数据结构的集合并测试)(掌握)</p><ul><li><p>A:案例演示</p><ul><li>需求：请用LinkedList模拟栈数据结构的集合，并测试</li><li>创建一个类将Linked中的方法封装</li><li><pre><code>public class Stack {    private LinkedList list = new LinkedList();        //创建LinkedList对象    public void in(Object obj) {        list.addLast(obj);                            //封装addLast()方法    }    public Object out() {        return list.removeLast();                    //封装removeLast()方法    }    public boolean isEmpty() {        return list.isEmpty();                        //封装isEmpty()方法    }}</code></pre></li></ul></li></ul><p>###16.06_集合框架(泛型概述和基本使用)(掌握)</p><ul><li>A:泛型概述</li><li>B:泛型好处<ul><li>提高安全性(将运行期的错误转换到编译期) </li><li>省去强转的麻烦</li></ul></li><li>C:泛型基本使用<ul><li>&lt;&gt;中放的必须是引用数据类型 </li></ul></li><li>D:泛型使用注意事项<ul><li>前后的泛型必须一致,或者后面的泛型可以省略不写(1.7的新特性菱形泛型)  </li></ul></li></ul><p>###16.07_集合框架(ArrayList存储字符串和自定义对象并遍历泛型版)(掌握)</p><ul><li>A:案例演示<ul><li>ArrayList存储字符串并遍历泛型版</li></ul></li></ul><p>###16.08_集合框架(泛型的由来)(了解)</p><ul><li>A:案例演示<ul><li>泛型的由来:通过Object转型问题引入</li><li>早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题。</li></ul></li></ul><p>###16.09_集合框架(泛型类的概述及使用)(了解)</p><ul><li>A:泛型类概述<t><ul><li>把泛型定义在类上</li></ul></t></li><li>B:定义格式<ul><li>public class 类名&lt;泛型类型1,…&gt;</li></ul></li><li>C:注意事项    <ul><li>泛型类型必须是引用类型</li></ul></li><li>D:案例演示<ul><li>泛型类的使用</li></ul></li></ul><p>###16.10_集合框架(泛型方法的概述和使用)(了解)</p><ul><li>A:泛型方法概述<ul><li>把泛型定义在方法上</li></ul></li><li>B:定义格式    <ul><li>public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 变量名)</li></ul></li><li>C:案例演示<ul><li>泛型方法的使用</li></ul></li></ul><p>###16.11_集合框架(泛型接口的概述和使用)(了解)</p><ul><li>A:泛型接口概述<ul><li>把泛型定义在接口上</li></ul></li><li>B:定义格式    <ul><li>public interface 接口名&lt;泛型类型&gt;</li></ul></li><li>C:案例演示<ul><li>泛型接口的使用</li></ul></li></ul><p>###16.12_集合框架(泛型高级之通配符)(了解)</p><ul><li>A:泛型通配符&lt;?&gt;<ul><li>任意类型，如果没有明确，那么就是Object以及任意的Java类了</li></ul></li><li>B:? extends E<ul><li>向下限定，E及其子类</li></ul></li><li><p>C:? super E</p><ul><li><p>向上限定，E及其父类</p><p>List&lt;?&gt; list = new ArrayList<integer>();            //当右边的泛型是不确定时,左边可以指定为?</integer></p></li></ul></li></ul><p>###16.13_集合框架(增强for的概述和使用)(掌握)</p><ul><li>A:增强for概述（底层是用Iterator迭代器实现的）<ul><li>简化数组和Collection集合的遍历</li></ul></li><li>B:格式：</li><li><pre><code>for(元素数据类型 变量 : 数组或者Collection集合) {    使用变量即可，该变量就是元素}</code></pre></li><li>C:案例演示<ul><li>数组，集合存储元素用增强for遍历</li></ul></li><li>D:好处<ul><li>简化遍历</li></ul></li></ul><p>###16.14_集合框架(ArrayList存储字符串和自定义对象并遍历增强for版)(掌握)</p><ul><li><p>A:案例演示</p><ul><li>ArrayList存储字符串并遍历增强for版</li><li><pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;c&quot;);list.add(&quot;d&quot;);for(String s : list) {    System.out.println(s);}</code></pre><p>###16.15_集合框架(三种迭代的能否删除)(掌握)</p></li></ul></li><li>普通for循环,可以删除,但是索引要–  （因为删除数组中的一个元素后后面的元素会向上补齐）</li><li>迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常</li><li>增强for循环不能删除，（增强for的底层依赖的是Iterator迭代器，会发生并发修改异常）</li></ul><p>###16.16_集合框架(静态导入的概述和使用)(掌握)</p><ul><li>A:静态导入概述</li><li>B:格式：<ul><li>import static 包名….类名.方法名;</li><li>可以直接导入到方法的级别</li></ul></li><li>C:注意事项<ul><li>方法必须是静态的,如果有多个同名的静态方法，容易不知道使用谁?这个时候要使用，必须加前缀。由此可见，意义不大，所以一般不用，但是要能看懂。</li></ul></li></ul><p>###16.17_集合框架(可变参数的概述和使用)(掌握)</p><ul><li>A:可变参数概述<ul><li>定义方法的时候不知道该定义多少个参数</li></ul></li><li>B:格式<ul><li>修饰符 返回值类型 方法名(数据类型…  变量名){}</li></ul></li><li>C:注意事项：<ul><li>这里的变量其实是一个数组（可变参数其实是数组。长度可变）</li><li>如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个</li></ul></li></ul><p>###16.18_集合框架(Arrays工具类的asList()方法的使用)(掌握)</p><ul><li><p>A:案例演示</p><ul><li><p>Arrays工具类的asList()方法的使用<br>  *数组转换成集合</p><ul><li><p>数组转换成集合虽然不能增加或减少元素,但是可以用集合的思想操作数组,也就是说可以使用其他集合中的方法<br>List<string> list = Arrays.asList(arr);                //将数组转换成集合<br>list.add(“d”);                                        //不能添加</string></p><p>  <strong>基本数据类型的数组转换成集合,会将整个数组当作一个对象转换  </strong>将数组转换成集合,数组必须是引用数据类型</p><p>  <strong>当集合转换数组时,数组长度如果是小于等于集合的size时,转换后的数组长度等于集合的size  </strong>如果数组的长度大于了size,分配的数组长度就和你指定的长度一样</p></li></ul></li><li>Collection中toArray(T[] a)泛型版的集合转数组</li></ul></li></ul><p>###16.19_集合框架(集合嵌套之ArrayList嵌套ArrayList)(掌握)</p><ul><li>A:案例演示<ul><li>集合嵌套之ArrayList嵌套ArrayList</li></ul></li></ul><p>###16.20_day16总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###16.01_集合框架(去除ArrayList中重复字符串元素方式)(掌握)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A:案例演示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求：ArrayList去除集合中字符串的重复值(字符串的内容相同)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;思路：创建新集合方式&lt;/p
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ArrayList，泛型" scheme="http://zouyip.github.io/tags/ArrayList%EF%BC%8C%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>List</title>
    <link href="http://zouyip.github.io/2017/09/10/day15-List%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/10/day15-List笔记/</id>
    <published>2017-09-10T09:55:30.000Z</published>
    <updated>2017-10-25T01:47:41.283Z</updated>
    
    <content type="html"><![CDATA[<p>###15.01_集合框架(对象数组的概述和使用)</p><ul><li>A:案例演示<ul><li>需求：我有5个学生，请把这个5个学生的信息存储到数组中，并遍历数组，获取得到每一个学生信息。</li></ul></li><li><pre><code>Student[] arr = new Student[5];                    //存储学生对象arr[0] = new Student(&quot;张三&quot;, 23);arr[1] = new Student(&quot;李四&quot;, 24);arr[2] = new Student(&quot;王五&quot;, 25);arr[3] = new Student(&quot;赵六&quot;, 26);arr[4] = new Student(&quot;马哥&quot;, 20);for (int i = 0; i &lt; arr.length; i++) {    System.out.println(arr[i]);}</code></pre></li><li><p>B:画图演示</p><ul><li>把学生数组的案例画图讲解</li><li>数组和集合存储引用数据类型,存的都是地址值</li></ul></li></ul><p>###15.02_集合框架(集合的由来及集合继承体系图)</p><ul><li>A:集合的由来<ul><li>数组长度是固定,当添加的元素超过了数组的长度时需要对数组重新定义,太麻烦,java内部给我们提供了集合类,<br>能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少 </li></ul></li><li>B:数组和集合的区别<ul><li>区别1 : <ul><li>数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值</li><li>集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象</li></ul></li><li>区别2:<ul><li>数组长度是固定的,不能自动增长</li><li>集合的长度的是可变的,可以根据元素的增加而增长</li></ul></li></ul></li><li>C:数组和集合什么时候用<pre><code>* 1,如果元素个数是固定的推荐用数组* 2,如果元素个数不是固定的推荐用集合</code></pre></li><li>D:集合继承体系图</li></ul><p>###15.03_集合框架(Collection集合的基本功能测试)</p><ul><li>A:案例演示    </li><li><pre><code>基本功能演示boolean add(E e)boolean remove(Object o)void clear()boolean contains(Object o)boolean isEmpty()int size()</code></pre></li><li><p>B:注意:</p></li><li><pre><code>collectionXxx.java使用了未经检查或不安全的操作.注意:要了解详细信息,请使用 -Xlint:unchecked重新编译.java编译器认为该程序存在安全隐患温馨提示:这不是编译失败,所以先不用理会,等学了泛型你就知道了</code></pre></li></ul><p>###15.04_集合框架(集合的遍历之集合转数组遍历)</p><ul><li>A:集合的遍历<ul><li>其实就是依次获取集合中的每一个元素。</li></ul></li><li><p>B:案例演示</p><ul><li>把集合转成数组，可以实现集合的遍历</li><li><p>toArray()<br>*</p><pre><code>Collection coll = new ArrayList();coll.add(new Student(&quot;张三&quot;,23));        //Object obj = new Student(&quot;张三&quot;,23);coll.add(new Student(&quot;李四&quot;,24));coll.add(new Student(&quot;王五&quot;,25));coll.add(new Student(&quot;赵六&quot;,26));Object[] arr = coll.toArray();                //将集合转换成数组for (int i = 0; i &lt; arr.length; i++) {    Student s = (Student)arr[i];            //强转成Student    System.out.println(s.getName() + &quot;,&quot; + s.getAge());}</code></pre></li></ul></li></ul><p>###15.05_集合框架(Collection集合的带All功能测试)</p><ul><li>A:案例演示</li><li><pre><code>带All的功能演示boolean addAll(Collection c)        c1.addAll(c2);                //将c2中的每一个元素添加到c1中    c1.add(c2);                    //将c2看成一个对象添加到c1中boolean removeAll(Collection c)        删除的是交集boolean containsAll(Collection c)    判断调用的集合是否包含传入的集合boolean retainAll(Collection c)        取交集,如果调用的集合改变就返回true,如果调用的集合不变就返回false</code></pre></li></ul><p>###15.06_集合框架(集合的遍历之迭代器遍历)</p><ul><li>A:迭代器概述<ul><li>集合是用来存储元素,存储的元素需要查看,那么就需要迭代(遍历) </li></ul></li><li><p>B:案例演示</p><ul><li><p>迭代器的使用</p><pre><code>Collection c = new ArrayList();c.add(&quot;a&quot;);c.add(&quot;b&quot;);c.add(&quot;c&quot;);c.add(&quot;d&quot;);Iterator it = c.iterator();                        //获取迭代器的引用while(it.hasNext()) {                            //集合中的迭代方法(遍历)    System.out.println(it.next());}</code></pre></li></ul></li></ul><p>###15.07_集合框架(Collection存储自定义对象并遍历)</p><ul><li><p>A:案例演示</p><ul><li>Collection存储自定义对象并用迭代器遍历</li><li><pre><code>Collection c = new ArrayList();c.add(new Student(&quot;张三&quot;,23));c.add(new Student(&quot;李四&quot;,24));c.add(new Student(&quot;王五&quot;,25));c.add(new Student(&quot;赵六&quot;,26));c.add(new Student(&quot;赵六&quot;,26));for(Iterator it = c.iterator();it.hasNext();) {    Student s = (Student)it.next();                        //向下转型    System.out.println(s.getName() + &quot;,&quot; + s.getAge());    //获取对象中的姓名和年龄}System.out.println(&quot;------------------------------&quot;);Iterator it = c.iterator();                                //获取迭代器while(it.hasNext()) {                                    //判断集合中是否有元素    //System.out.println(((Student)(it.next())).getName() + &quot;,&quot; + ((Student)(it.next())).getAge());    Student s = (Student)it.next();                        //向下转型    System.out.println(s.getName() + &quot;,&quot; + s.getAge());    //获取对象中的姓名和年龄}</code></pre></li></ul></li></ul><p>###15.08_集合框架(迭代器的原理及源码解析)(了解)</p><ul><li>A:迭代器原理<ul><li>迭代器原理:迭代器是对集合进行遍历,而每一个集合内部的存储结构都是不同的,所以每一个集合存和取都是不一样,<br>那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,<br>迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式（覆写了）,这样做的好处有二,<br>第一规定了整个集合体系的遍历方式都是hasNext()和next()方法,第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可 </li></ul></li><li>B:迭代器源码解析<ul><li>1,在eclipse中ctrl + shift + t找到ArrayList类</li><li>2,ctrl+o查找iterator()方法</li><li>3,查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口</li><li>4,查找Itr这个内部类,发现重写了Iterator中的所有抽象方法 </li></ul></li></ul><p>###15.09_集合框架(List集合的特有功能概述和测试)                List(数据结构：有序,可重复)</p><ul><li>A:List集合的特有功能概述<ul><li>void add(int index,E element)        通过索引增加元素（若无索引参数，则自动在后面增加）</li><li>E remove(int index)        通过索引删除元素,将被删除的元素返回</li><li>E get(int index)</li><li>E set(int index,E element)</li></ul></li></ul><p>###15.10_集合框架(List集合存储学生对象并遍历)</p><ul><li><p>A:案例演示</p><ul><li><p>通过size()和get()方法结合使用遍历。</p><pre><code>List list = new ArrayList();list.add(new Student(&quot;张三&quot;, 18));list.add(new Student(&quot;李四&quot;, 18));list.add(new Student(&quot;王五&quot;, 18));list.add(new Student(&quot;赵六&quot;, 18));for(int i = 0; i &lt; list.size(); i++) {    Student s = (Student)list.get(i);    System.out.println(s.getName() + &quot;,&quot; + s.getAge());}</code></pre></li></ul></li></ul><p>###15.11_集合框架(并发修改异常产生的原因及解决方案)</p><ul><li><p>A:案例演示</p><ul><li><p>需求：我有一个集合，请问，我想判断里面有没有”world”这个元素，如果有，我就添加一个”javaee”元素，请写代码实现。</p><pre><code>List list = new ArrayList();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;world&quot;);list.add(&quot;d&quot;);list.add(&quot;e&quot;);/*Iterator it = list.iterator();while(it.hasNext()) {    String str = (String)it.next();    if(str.equals(&quot;world&quot;)) {        list.add(&quot;javaee&quot;);            //这里会抛出ConcurrentModificationException并发修改异常    }}*/</code></pre></li></ul></li></ul><ul><li>B:ConcurrentModificationException出现<ul><li>迭代器遍历，集合修改集合</li></ul></li><li><p>C:解决方案</p><ul><li>a:迭代器迭代元素，迭代器修改元素(ListIterator的特有功能add)</li><li><p>b:集合遍历元素，集合修改元素</p><pre><code>ListIterator lit = list.listIterator();        //如果想在遍历的过程中添加元素,可以用ListIterator中的add方法while(lit.hasNext()) {    String str = (String)lit.next();    if(str.equals(&quot;world&quot;)) {        lit.add(&quot;javaee&quot;);            //list.add(&quot;javaee&quot;);    }}</code></pre></li></ul></li></ul><p>###15.12_集合框架(ListIterator)(了解)</p><ul><li>boolean hasNext()是否有下一个</li><li>boolean hasPrevious()是否有前一个</li><li>Object next()返回下一个元素， 获取元素并将指针向后移动</li><li>Object previous();返回上一个元素，获取元素并将指针向前移动</li></ul><p>###15.13_集合框架(Vector的特有功能)</p><ul><li>A:Vector类概述</li><li>B:Vector类特有功能<ul><li>public void addElement(E obj)</li><li>public E elementAt(int index)</li><li>public Enumeration elements()</li></ul></li><li><p>C:案例演示    </p><ul><li><p>Vector的迭代（Vector是用枚举Enumeration迭代）</p><pre><code>Vector v = new Vector();                //创建集合对象,List的子类v.addElement(&quot;a&quot;);v.addElement(&quot;b&quot;);v.addElement(&quot;c&quot;);v.addElement(&quot;d&quot;);//Vector迭代Enumeration en = v.elements();            //获取枚举while(en.hasMoreElements()) {            //判断集合中是否有元素    System.out.println(en.nextElement());//获取集合中的元素}</code></pre></li></ul></li></ul><p>###15.14_集合框架(数据结构之数组和链表：链表增删快，改查慢。数组则相反)</p><ul><li>A:数组<ul><li>查询快修改也快</li><li>增删慢</li></ul></li><li>B:链表<ul><li>查询慢,修改也慢</li><li>增删快</li></ul></li></ul><p>###15.15_集合框架(List的三个子类的特点)</p><ul><li>A:List的三个子类的特点</li><li><pre><code>ArrayList:    底层数据结构是数组，查询快，增删慢。    线程不安全，效率高。线程不同步Vector:    底层数据结构是数组，查询快，增删慢。    线程安全，效率低。Vector相对ArrayList查询慢(线程安全的)Vector相对LinkedList（链表结构）增删慢(数组结构)LinkedList:    底层数据结构是链表，查询慢，增删快。    线程不安全，效率高。Vector和ArrayList的区别    Vector是线程安全的,效率低    ArrayList是线程不安全的,效率高。线程同步共同点:都是数组实现的ArrayList和LinkedList的区别    ArrayList底层是数组结果,查询和修改快    LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢共同点:都是线程不安全的</code></pre></li><li>B:List有三个儿子，我们到底使用谁呢?<pre><code>查询多用ArrayList增删多用LinkedList如果都多ArrayList（Vector已经被ArrayList完全取代了，如果要求线程安全可以使用工具类，将ArrayList变为线程安全的，                    所以Vector已经几乎不再使用了）</code></pre>###15.16_day15总结<br>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###15.01_集合框架(对象数组的概述和使用)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:案例演示&lt;ul&gt;
&lt;li&gt;需求：我有5个学生，请把这个5个学生的信息存储到数组中，并遍历数组，获取得到每一个学生信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;Stud
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="List" scheme="http://zouyip.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式与Date类</title>
    <link href="http://zouyip.github.io/2017/09/07/day14-Date%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/07/day14-Date笔记/</id>
    <published>2017-09-07T10:55:30.000Z</published>
    <updated>2017-10-25T01:46:31.710Z</updated>
    
    <content type="html"><![CDATA[<p>###14.01_常见对象(正则表达式的概述和简单使用)</p><ul><li>A:正则表达式<ul><li>是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。</li><li>作用:比如注册邮箱,邮箱有用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的</li></ul></li><li><p>B:案例演示</p><ul><li><p>需求：校验qq号码.</p><ul><li>1:要求必须是5-15位数字</li><li>2:0不能开头</li><li>3:必须都是数字</li></ul></li><li><p>a:非正则表达式实现</p></li><li>b:正则表达式实现</li></ul></li></ul><p>###14.02_常见对象(字符类演示)</p><ul><li>A:字符类<ul><li>[abc] a、b 或 c（简单类） </li><li>[^abc] 任何字符，除了 a、b 或 c（否定） </li><li>[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） </li><li>[0-9] 0到9的字符都包括<br>###14.03_常见对象(预定义字符类演示)</li></ul></li><li>A:预定义字符类<ul><li>. 任何字符。</li><li>\d 数字：[0-9]</li><li>\w 单词字符：[a-zA-Z<em>0-9]<br>###14.04</em>常见对象(数量词)</li></ul></li><li>A:Greedy 数量词 <ul><li>X? X，一次或一次也没有</li><li>X* X，零次或多次</li><li>X+ X，一次或多次</li><li>X{n} X，恰好 n 次 </li><li>X{n,} X，至少 n 次 </li><li>X{n,m} X，至少 n 次，但是不超过 m 次 </li></ul></li></ul><p>###14.05_常见对象(正则表达式的分割功能)</p><ul><li>A:正则表达式的分割功能<ul><li>String类的功能：public String[] split(String regex)</li></ul></li><li>B:案例演示<ul><li>正则表达式的分割功能</li></ul></li></ul><p>###14.06_常见对象(把给定字符串中的数字排序)</p><ul><li>A:案例演示<ul><li>需求：我有如下一个字符串:”91 27 46 38 50”，请写代码实现最终输出结果是：”27 38 46 50 91”</li><li>分析:<ul><li>1,将字符串切割成字符串数组        public String[] split(String regex) 返回值是字符串数组</li><li>2,将字符串转换成数字并将其存储在一个等长度的int数组中</li><li>3,排序</li><li>4,将排序后的结果遍历并拼接成一个字符串</li></ul></li></ul></li></ul><p>###14.07_常见对象(正则表达式的替换功能)</p><ul><li>A:正则表达式的替换功能<ul><li>String类的功能：public String replaceAll(String regex,String replacement)</li></ul></li><li>B:案例演示<ul><li>正则表达式的替换功能</li></ul></li></ul><p>###14.08_常见对象(正则表达式的分组功能)</p><ul><li>A:正则表达式的分组功能<ul><li>捕获组可以通过从左到右计算其开括号来编号。例如，在表达式 ((A)(B(C))) 中，存在四个这样的组： </li></ul></li><li><pre><code>1     ((A)(B(C))) 2     (A 3     (B(C)) 4     (C) 组零始终代表整个表达式。</code></pre><p>B:案例演示<br>  a:切割</p><pre><code>需求：请按照叠词切割： &quot;sdqqfgkkkhjppppkl&quot;;</code></pre><p>  b:替换</p><pre><code>需求：我我....我...我.要...要要...要学....学学..学.编..编编.编.程.程.程..程将字符串还原成:“我要学编程”。</code></pre><p>###14.09_常见对象(Pattern和Matcher的概述)</p></li><li>A:Pattern和Matcher的概述</li><li><p>B:模式和匹配器的典型调用顺序</p><ul><li><p>通过JDK提供的API，查看Pattern类的说明</p></li><li><p>典型的调用顺序是 </p></li><li>Pattern p = Pattern.compile(“a*b”);</li><li>Matcher m = p.matcher(“aaaaab”);</li><li>boolean b = m.matches();</li></ul></li></ul><p>###14.10_常见对象(正则表达式的获取功能)</p><ul><li>A:正则表达式的获取功能<ul><li>Pattern和Matcher的结合使用</li></ul></li><li>B:案例演示<ul><li>需求：把一个字符串中的手机号码获取出来</li></ul></li></ul><p>###14.11_常见对象(Math类概述和方法使用)</p><ul><li>A:Math类概述<ul><li>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 </li></ul></li><li>B:成员方法<ul><li>public static int abs(int a)</li><li>public static double ceil(double a)</li><li>public static double floor(double a)</li><li>public static int max(int a,int b) min自学</li><li>public static double pow(double a,double b)</li><li>public static double random()</li><li>public static int round(float a) 参数为double的自学</li><li>public static double sqrt(double a)</li></ul></li></ul><p>###14.12_常见对象(Random类的概述和方法使用)</p><ul><li>A:Random类的概述<ul><li>此类用于产生随机数如果用相同的种子创建两个 Random 实例，</li><li>则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列。</li></ul></li><li>B:构造方法<br>  <em>Random() ：创建一个新的随机数发生器。  </em>Random(long seed) ：用一个种子（长整型）创建一个随机数发生器。</li><li>C:成员方法：nextInt(int n) 方法用于获取一个伪随机，在0(包括)和指定值(不包括)，<pre><code>从此随机数生成器的序列中取出均匀分布的int值。</code></pre><ul><li>public int nextInt()</li><li>public int nextInt(int n)(重点掌握)</li></ul></li></ul><p>###14.13_常见对象(System类的概述和方法使用)</p><ul><li>A:System类的概述<ul><li>System 类包含一些有用的类字段和方法。它不能被实例化。 </li></ul></li><li>B:成员方法<ul><li>public static void gc()</li><li>public static void exit(int status)</li><li>public static long currentTimeMillis()</li><li>pubiic static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) </li></ul></li><li>C:案例演示<ul><li>System类的成员方法使用</li></ul></li></ul><p>###14.14_常见对象(BigInteger类的概述和方法使用)</p><ul><li>A:BigInteger的概述<ul><li>可以让超过Integer范围内的数据进行运算</li></ul></li><li>B:构造方法<ul><li>public BigInteger(String val)</li></ul></li><li>C:成员方法<ul><li>public BigInteger add(BigInteger val)</li><li>public BigInteger subtract(BigInteger val)</li><li>public BigInteger multiply(BigInteger val)</li><li>public BigInteger divide(BigInteger val)</li><li>public BigInteger[] divideAndRemainder(BigInteger val)</li></ul></li></ul><p>###14.15_常见对象(BigDecimal类的概述和方法使用)</p><ul><li><p>A:BigDecimal的概述</p><ul><li>由于在运算的时候，float类型和double很容易丢失精度，演示案例。</li><li><p>所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal</p></li><li><p>不可变的、任意精度的有符号十进制数。</p></li></ul></li><li>B:构造方法<ul><li>public BigDecimal(String val)</li></ul></li><li>C:成员方法<ul><li>public BigDecimal add(BigDecimal augend)</li><li>public BigDecimal subtract(BigDecimal subtrahend)</li><li>public BigDecimal multiply(BigDecimal multiplicand)</li><li>public BigDecimal divide(BigDecimal divisor)</li></ul></li><li>D:案例演示<ul><li>BigDecimal类的构造方法和成员方法使用</li></ul></li></ul><p>###14.16_常见对象(Date类的概述和方法使用)(掌握)</p><ul><li>A:Date类的概述<ul><li>类 Date 表示特定的瞬间，精确到毫秒。 </li></ul></li><li>B:构造方法<ul><li>public Date()</li><li>public Date(long date)</li></ul></li><li>C:成员方法<ul><li>public long getTime()</li><li>public void setTime(long time)</li></ul></li></ul><p>###14.17_常见对象(SimpleDateFormat类实现日期和字符串的相互转换)(掌握)</p><ul><li>A:DateFormat类的概述<ul><li>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。是抽象类，所以使用其子类SimpleDateFormat</li></ul></li><li>B:SimpleDateFormat构造方法<ul><li>public SimpleDateFormat()</li><li>public SimpleDateFormat(String pattern)</li></ul></li><li>C:成员方法<ul><li>public final String format(Date date)</li><li>public Date parse(String source)</li></ul></li></ul><p>###14.18_常见对象(你来到这个世界多少天案例)(掌握)</p><ul><li>A:案例演示<ul><li>需求：算一下你来到这个世界多少天?</li></ul></li></ul><p>###14.19_常见对象(Calendar类的概述和获取日期的方法)(掌握)</p><ul><li>A:Calendar类的概述<ul><li>Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</li></ul></li><li>B:成员方法<ul><li>public static Calendar getInstance()</li><li>public int get(int field)</li></ul></li></ul><p>###14.20_常见对象(Calendar类的add()和set()方法)(掌握)</p><ul><li>A:成员方法<ul><li>public void add(int field,int amount)</li><li>public final void set(int year,int month,int date)</li></ul></li><li>B:案例演示<ul><li>Calendar类的成员方法使用</li></ul></li></ul><p>###14.21_常见对象(如何获取任意年份是平年还是闰年)(掌握)</p><ul><li>A:案例演示<ul><li>需求：键盘录入任意一个年份，判断该年是闰年还是平年</li></ul></li></ul><p>###14.22_day14总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###14.01_常见对象(正则表达式的概述和简单使用)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:正则表达式&lt;ul&gt;
&lt;li&gt;是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。&lt;/li&gt;
&lt;li&gt;作用:比如注册邮箱,邮箱有用户名和
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="正则，Date类" scheme="http://zouyip.github.io/tags/%E6%AD%A3%E5%88%99%EF%BC%8CDate%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>StringBuffer类</title>
    <link href="http://zouyip.github.io/2017/09/07/day13-StringBuffer%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/07/day13-StringBuffer笔记/</id>
    <published>2017-09-07T03:50:30.000Z</published>
    <updated>2017-10-25T01:37:24.518Z</updated>
    
    <content type="html"><![CDATA[<p>###13.01_常见对象(StringBuffer类的概述)</p><ul><li>A:StringBuffer类概述<ul><li>通过JDK提供的API，查看StringBuffer类的说明</li><li>线程安全的可变字符序列 </li></ul></li><li>B:StringBuffer和String的区别<ul><li>String是一个不可变的字符序列</li><li>StringBuffer是一个可变的字符序列 </li></ul></li></ul><p>###13.02_常见对象(StringBuffer类的构造方法)</p><ul><li>A:StringBuffer的构造方法：<ul><li>public StringBuffer():无参构造方法</li><li>public StringBuffer(int capacity):指定容量的字符串缓冲区对象</li><li>public StringBuffer(String str):指定字符串内容的字符串缓冲区对象</li></ul></li><li>B:StringBuffer的方法：<ul><li>public int capacity()：返回当前容量。    理论值(不掌握)</li><li>public int length():返回长度（字符数）。 实际值</li></ul></li><li>C:案例演示<ul><li>构造方法和长度方法的使用</li></ul></li></ul><p>###13.03_常见对象(StringBuffer的添加功能)</p><ul><li><p>A:StringBuffer的添加功能</p><ul><li>public StringBuffer append(String str):<ul><li>可以把任意类型数据添加到字符串缓冲区里面,并返回字符串缓冲区本身</li></ul></li><li><p>public StringBuffer insert(int offset,String str):</p><ul><li>在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身</li></ul><p>StringBuffer是字符串缓冲区,当new的时候是在堆内存创建了一个对象,底层是一个长度为16的字符数组<br>  当调用添加的方法时,不会再重新创建对象,在不断向原缓冲区添加字符</p></li></ul></li></ul><p>###13.04_常见对象(StringBuffer的删除功能)</p><ul><li>A:StringBuffer的删除功能<ul><li>public StringBuffer deleteCharAt(int index):<ul><li>删除指定位置的字符，并返回本身</li></ul></li><li>public StringBuffer delete(int start,int end):<ul><li>删除从指定位置开始指定位置结束的内容，并返回本身</li></ul></li></ul></li></ul><p>###13.05_常见对象(StringBuffer的替换和反转功能)</p><ul><li>A:StringBuffer的替换功能<ul><li>public StringBuffer replace(int start,int end,String str):<ul><li>从start开始到end用str替换</li></ul></li></ul></li><li>B:StringBuffer的反转功能<ul><li>public StringBuffer reverse():<ul><li>字符串反转</li></ul></li></ul></li></ul><p>###13.06_常见对象(StringBuffer的截取功能及注意事项)</p><ul><li>A:StringBuffer的截取功能<ul><li>public String substring(int start):<ul><li>从指定位置截取到末尾</li></ul></li><li>public String substring(int start,int end):<ul><li>截取从指定位置开始到结束位置，包括开始位置，不包括结束位置</li></ul></li></ul></li><li>B:注意事项<ul><li>注意:返回值类型不再是StringBuffer本身</li></ul></li></ul><p>###13.07_常见对象(StringBuffer和String的相互转换)</p><ul><li>A:String – StringBuffer<ul><li>a:通过构造方法</li><li>b:通过append()方法</li></ul></li><li>B:StringBuffer – String<ul><li>a:通过构造方法</li><li>b:通过toString()方法</li><li>c:通过subString(0,length);</li></ul></li></ul><p>###13.08_常见对象(把数组转成字符串)</p><ul><li><p>A:案例演示</p><ul><li>需求：把数组中的数据按照指定个格式拼接成一个字符串</li><li><pre><code>举例：    int[] arr = {1,2,3};    输出结果：    &quot;[1, 2, 3]&quot;用StringBuffer的功能实现</code></pre></li></ul></li></ul><p>###13.09_常见对象(字符串反转)</p><ul><li>A:案例演示</li><li><pre><code>需求：把字符串反转    举例：键盘录入&quot;abc&quot;            输出结果：&quot;cba&quot;用StringBuffer的功能实现    </code></pre></li></ul><p>###13.10_常见对象(StringBuffer和StringBuilder的区别)</p><ul><li>A:StringBuilder的概述<ul><li>通过查看API了解一下StringBuilder类</li></ul></li><li><p>B:面试题</p><ul><li>String,StringBuffer,StringBuilder的区别</li><li>StringBuffer和StringBuilder的区别</li><li>StringBuffer是jdk1.0版本的,是线程安全的,效率低</li><li><p>StringBuilder是jdk1.5版本的,是线程不安全的,效率高</p></li><li><p>String和StringBuffer,StringBuilder的区别</p></li><li>String是一个不可变的字符序列</li><li>StringBuffer,StringBuilder是可变的字符序列</li></ul></li></ul><p>###13.11_常见对象(String和StringBuffer分别作为参数传递)</p><ul><li>A:形式参数问题<ul><li>String作为参数传递</li><li>StringBuffer作为参数传递 </li></ul></li><li>B:案例演示<ul><li>String和StringBuffer分别作为参数传递问题</li></ul></li></ul><p>###13.12_常见对象(数组高级冒泡排序原理图解)</p><ul><li>A:画图演示</li><li><pre><code>需求：    数组元素：{24, 69, 80, 57, 13}    请对数组元素进行排序。    冒泡排序        相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处</code></pre></li></ul><p>###13.13_常见对象(数组高级冒泡排序代码实现)</p><ul><li>A:案例演示<ul><li>数组高级冒泡排序代码</li></ul></li></ul><p>###13.14_常见对象(数组高级选择排序原理图解)</p><ul><li><p>A:画图演示</p><ul><li><p>需求：</p><ul><li>数组元素：{24, 69, 80, 57, 13}</li><li><p>请对数组元素进行排序。</p></li><li><p>选择排序</p><ul><li>从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处</li></ul></li></ul></li></ul></li></ul><p>###13.15_常见对象(数组高级选择排序代码实现)</p><ul><li>A:案例演示<ul><li>数组高级选择排序代码</li></ul></li></ul><p>###13.16_常见对象(数组高级二分查找原理图解)</p><ul><li>A:画图演示<ul><li>二分查找  </li><li>前提：数组元素有序</li></ul></li></ul><p>###13.17_常见对象(数组高级二分查找代码实现及注意事项)</p><ul><li>A:案例演示<ul><li>数组高级二分查找代码</li></ul></li><li>B:注意事项<ul><li>如果数组无序，就不能使用二分查找。<ul><li>因为如果你排序了，但是你排序的时候已经改变了我最原始的元素索引。</li></ul></li></ul></li></ul><p>####总结：循环嵌套的排序算法中外层循环控制的是比较的次数。</p><p>###13.18_常见对象(Arrays类的概述和方法使用)</p><ul><li>A:Arrays类概述<ul><li>针对数组进行操作的工具类。</li><li>提供了排序，查找等功能。</li></ul></li><li>B:成员方法<ul><li>public static String toString(int[] a)</li><li>public static void sort(int[] a)</li><li>public static int binarySearch(int[] a,int key)</li></ul></li></ul><p>###13.19_常见对象(基本类型包装类的概述)</p><ul><li>A:为什么会有基本类型包装类<ul><li>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。</li></ul></li><li>B:常用操作<ul><li>常用的操作之一：用于基本数据类型与字符串之间的转换。</li></ul></li><li>C:基本类型和包装类的对应</li><li><pre><code>byte             Byteshort            Shortint                Integerlong            Longfloat            Floatdouble            Doublechar            Characterboolean            Boolean</code></pre></li></ul><p>###13.20_常见对象(Integer类的概述和构造方法)</p><ul><li><p>A:Integer类概述</p><ul><li><p>通过JDK提供的API，查看Integer类的说明</p></li><li><p>Integer 类在对象中包装了一个基本类型 int 的值,</p></li><li>该类提供了多个方法，能在 int 类型和 String 类型之间互相转换，</li><li>还提供了处理 int 类型时非常有用的其他一些常量和方法</li></ul></li><li>B:构造方法<ul><li>public Integer(int value)</li><li>public Integer(String s)<br>  //Integer i2 = new Integer(“abc”);            //java.lang.NumberFormatException数字格式异常<br>  //System.out.println(i2);                    //因为abc不是数字字符串,所以转换会报错</li></ul></li><li>C:案例演示<ul><li>使用构造方法创建对象</li></ul></li></ul><p>###13.21_常见对象(String和int类型的相互转换)</p><ul><li>A:int – String<ul><li>a:和””进行拼接</li><li>b:public static String valueOf(int i)</li><li>c:int – Integer – String(Integer类的toString方法())</li><li>d:public static String toString(int i)(Integer类的静态方法)</li></ul></li><li>B:String – int<ul><li>a:String – Integer – int</li><li>public static int parseInt(String s)</li></ul></li></ul><p>###13.22_常见对象(JDK5的新特性自动装箱和拆箱)</p><ul><li>A:JDK5的新特性<ul><li>自动装箱：把基本类型转换为包装类类型</li><li>自动拆箱：把包装类类型转换为基本类型</li></ul></li><li><p>B:案例演示</p><ul><li><p>JDK5的新特性自动装箱和拆箱</p></li><li><p>Integer ii = 100;</p></li><li>ii += 200;</li></ul></li><li>C:注意事项<ul><li>在使用时，Integer  x = null;代码就会出现NullPointerException。</li><li>建议先判断是否为null，然后再使用。</li></ul></li></ul><p>###13.23_常见对象(Integer的面试题)</p><ul><li>A:Integer的面试题</li><li><pre><code>看程序写结果Integer i1 = new Integer(97);Integer i2 = new Integer(97);System.out.println(i1 == i2);        //falseSystem.out.println(i1.equals(i2));    //trueSystem.out.println(&quot;-----------&quot;);Integer i3 = new Integer(197);Integer i4 = new Integer(197);System.out.println(i3 == i4);        //falseSystem.out.println(i3.equals(i4));    //trueSystem.out.println(&quot;-----------&quot;);Integer i5 = 97;Integer i6 = 97;System.out.println(i5 == i6);        //trueSystem.out.println(i5.equals(i6));    //true System.out.println(&quot;-----------&quot;);Integer i7 = 197;Integer i8 = 197;System.out.println(i7 == i8);        //falseSystem.out.println(i7.equals(i8));    //true    </code></pre></li><li><p>-128到127是byte的取值范围,如果在这个取值范围内,自动装箱就不会新创建对象,而是从常量池中获取</p><pre><code>* 如果超过了byte取值范围就会再新创建对象* * public static Integer valueOf(int i) {       assert IntegerCache.high &gt;= 127;       if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)            //i&gt;= -128 &amp;&amp; i &lt;= 127           return IntegerCache.cache[i + (-IntegerCache.low)];       return new Integer(i);   }*/</code></pre><p>  }</p></li></ul><p>}</p><p>###13.24_day13总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###13.01_常见对象(StringBuffer类的概述)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:StringBuffer类概述&lt;ul&gt;
&lt;li&gt;通过JDK提供的API，查看StringBuffer类的说明&lt;/li&gt;
&lt;li&gt;线程安全的可变字符序列 &lt;/li&gt;
&lt;/ul&gt;
&lt;/
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="StringBuffer" scheme="http://zouyip.github.io/tags/StringBuffer/"/>
    
  </entry>
  
  <entry>
    <title>String类概述</title>
    <link href="http://zouyip.github.io/2017/09/06/day12-String%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/06/day12-String笔记/</id>
    <published>2017-09-06T04:50:33.000Z</published>
    <updated>2017-10-25T01:38:17.942Z</updated>
    
    <content type="html"><![CDATA[<p>###12.01_常见对象(Scanner的概述和方法介绍)(掌握)</p><ul><li>A:Scanner的概述</li><li><p>B:Scanner的构造方法原理</p><ul><li>Scanner(InputStream source)</li><li>System类下有一个静态的字段：<ul><li>public static final InputStream in; 标准的输入流，对应着键盘录入。</li></ul></li></ul></li><li><p>C:一般方法</p><ul><li>hasNextXxx()  判断是否还有下一个输入项,其中Xxx可以是Int,Double等。如果需要判断是否包含下一个字符串，则可以省略Xxx</li><li>nextXxx()  获取下一个输入项。Xxx的含义和上个方法中的Xxx相同,默认情况下，Scanner使用空格，回车等作为分隔符</li></ul></li></ul><p>###12.02_常见对象(Scanner获取数据出现的小问题及解决方案)(掌握)</p><ul><li>A:两个常用的方法：<ul><li>public int nextInt():获取一个int类型的值</li><li>public String nextLine():获取一个String类型的值</li></ul></li><li>B:案例演示<ul><li>a:先演示获取多个int值，多个String值的情况</li><li>b:再演示先获取int值，然后获取String值出现问题</li><li>c:问题解决方案<ul><li>第一种：先获取一个数值后，再创建一个新的键盘录入对象获取字符串。</li><li>第二种：把所有的数据都先按照字符串获取，然后要什么，你就对应的转换为什么。(后面讲)</li></ul></li></ul></li></ul><p>###12.03_常见对象(String类的概述)(掌握)</p><ul><li><p>A:String类的概述    </p><ul><li><p>通过JDK提供的API，查看String类的说明</p></li><li><p>可以看到这样的两句话。</p><ul><li>a:字符串字面值”abc”也可以看成是一个字符串对象。</li><li>b:字符串是常量，一旦被赋值，就不能被改变。<br>String str = “abc”;                    //“abc”可以看成一个字符串对象<br>str = “def”;                        //当把”def”赋值给str,原来的”abc”就变成了垃圾<br>System.out.println(str);        //输出def，但是并不是改变了“abc”，而是重新创建了一个对象“def”并将地址值赋给了str</li></ul></li></ul></li></ul><p>###12.04_常见对象(String类的构造方法)(掌握)</p><ul><li>A:常见构造方法<ul><li>public String():空构造</li><li>public String(byte[] bytes):把字节数组转成字符串</li><li>public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串</li><li>public String(char[] value):把字符数组转成字符串</li><li>public String(char[] value,int index,int count):把字符数组的一部分转成字符串</li><li>public String(String original):把字符串常量值转成字符串</li></ul></li><li>B:案例演示    <ul><li>演示String类的常见构造方法</li></ul></li></ul><p>###12.05_常见对象(String类的常见面试题)(掌握)</p><ul><li>1.判断定义为String类型的s1和s2是否相等<ul><li>String s1 = “abc”;            //常量池中没有这个字符串对象,就创建一个,如果有直接用即可</li><li>String s2 = “abc”;</li><li>System.out.println(s1 == s2);         –true            </li><li>System.out.println(s1.equals(s2));     –true</li></ul></li><li>2.下面这句话在内存中创建了几个对象?<br>  //创建两个对象,一个在常量池中,一个在堆内存中<ul><li>String s1 = new String(“abc”);    –创建了两个对象，记录的是堆内存对象的地址值<pre><code>（在常量池中也会创建一个对象，堆中也会创建一个对象）堆中的对象相当于是常量池中的副本    </code></pre></li></ul></li><li>3.判断定义为String类型的s1和s2是否相等<ul><li>String s1 = new String(“abc”);        //记录的是堆内存对象的地址值        </li><li>String s2 = “abc”;                    //记录的是常量池中的地址值</li><li>System.out.println(s1 == s2); ?        –false</li><li>System.out.println(s1.equals(s2)); ?    –true</li></ul></li><li>4.判断定义为String类型的s1和s2是否相等<ul><li>String s1 = “a” + “b” + “c”;</li><li>String s2 = “abc”;</li><li>System.out.println(s1 == s2); ?            //true,java中有常量优化机制</li><li>System.out.println(s1.equals(s2)); ?        //true</li></ul></li><li>5.判断定义为String类型的s1和s2是否相等<ul><li>String s1 = “ab”;</li><li>String s2 = “abc”;</li><li>String s3 = s1 + “c”;</li><li>System.out.println(s3 == s2);                –false</li><li>System.out.println(s3.equals(s2)); ?        –true    </li></ul></li></ul><p>java语言提供对字符串串联符号（“+”）以及将其他对象转换为字符串的特殊支持。字符串串联是通过StringBuilder（或StringBuffer）<br>及其append方法实现的。字符串转换是通过toString方法是实现的。<br>    字符串常量直接赋值给String类声明的变量，则从常量池中寻找该字符串常量赋值给该变量，若常量池中没有创建该字符串常量则<br>    在常量池中创建该字符串常量然后赋值给该String变量<br>    eg：* String s1 = “abc”;</p><pre><code>    * String s2 = &quot;abc&quot;;    * System.out.println(s1 == s2);                         * System.out.println(s1.equals(s2));     其中s1与s2指向的是常量池中同一个常量，地址值相同。###12.06_常见对象(String类的判断功能)(掌握)</code></pre><ul><li>A:String类的判断功能<ul><li>boolean equals(Object obj):比较字符串的内容是否相同,区分大小写</li><li>boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</li><li>boolean contains(String str):判断大字符串中是否包含小字符串</li><li>boolean startsWith(String str):判断字符串是否以某个指定的字符串开头</li><li>boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾</li><li>boolean isEmpty():判断字符串是否为空。</li></ul></li></ul><p>###12.07_常见对象(模拟用户登录)(掌握)</p><ul><li>A:案例演示<ul><li>需求：模拟登录,给三次机会,并提示还有几次。</li><li>用户名和密码都是admin</li></ul></li></ul><p>###12.08_常见对象(String类的获取功能)(掌握)</p><ul><li>A:String类的获取功能<ul><li>int length():获取字符串的长度。</li><li>char charAt(int index):获取指定索引位置的字符</li><li>int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。</li><li>int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。</li><li>int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。</li><li>int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。</li><li>lastIndexOf</li><li>String substring(int start):从指定位置开始截取字符串,默认到末尾。</li><li>String substring(int start,int end):从指定位置开始到指定位置结束截取字符串。</li></ul></li></ul><p>###12.09_常见对象(字符串的遍历)(掌握)</p><ul><li>A:案例演示<ul><li>需求：遍历字符串</li></ul></li></ul><p>###12.10_常见对象(统计不同类型字符个数)(掌握)</p><ul><li>A:案例演示<ul><li>需求：统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数,其他字符出现的次数。</li><li>ABCDEabcd123456!@#$%^</li></ul></li></ul><p>###12.11_常见对象(String类的转换功能)(掌握)</p><ul><li>A:String的转换功能：<ul><li>byte[] getBytes():把字符串转换为字节数组。</li><li>char[] toCharArray():把字符串转换为字符数组。</li><li>static String valueOf(char[] chs):把字符数组转成字符串。</li><li>static String valueOf(int i):把int类型的数据转成字符串。<ul><li>注意：String类的valueOf方法可以把任意类型的数据转成字符串。</li></ul></li></ul></li></ul><pre><code>* String toLowerCase():把字符串转成小写。(了解)* String toUpperCase():把字符串转成大写。* String concat(String str):把字符串拼接。</code></pre><p>###12.12_常见对象(按要求转换字符)(链式编程掌握)</p><ul><li>A:案例演示<ul><li>需求：把一个字符串的首字母转成大写，其余为小写。(只考虑英文大小写字母字符)</li></ul></li></ul><p>###12.13_常见对象(把数组转成字符串)</p><ul><li>A:案例演示<ul><li>需求：把数组中的数据按照指定个格式拼接成一个字符串<ul><li>举例：<ul><li>int[] arr = {1,2,3};    </li></ul></li><li>输出结果：<ul><li>“[1, 2, 3]”<br>###12.14_常见对象(String类的其他功能)</li></ul></li></ul></li></ul></li><li>A:String的替换功能及案例演示<ul><li>String replace(char old,char new)</li><li>String replace(String old,String new)</li></ul></li><li>B:String的去除字符串两空格及案例演示<ul><li>String trim()</li></ul></li><li>C:String的按字典顺序比较两个字符串及案例演示<ul><li>int compareTo(String str)(暂时不用掌握)</li><li>int compareToIgnoreCase(String str)(了解)</li></ul></li></ul><p>###12.15_常见对象(字符串反转)</p><ul><li>A:案例演示<ul><li>需求：把字符串反转<ul><li>举例：键盘录入”abc”        </li><li>输出结果：”cba”</li></ul></li></ul></li></ul><p>###12.16_常见对象(在大串中查找小串出现的次数思路图解)</p><ul><li>A:画图演示<ul><li>需求：统计大串中小串出现的次数</li><li>这里的大串和小串可以自己根据情况给出</li></ul></li></ul><p>###12.17_常见对象(在大串中查找小串出现的次数代码实现)</p><ul><li>A:案例演示    <ul><li>统计大串中小串出现的次数</li></ul></li></ul><p><em>String对象的底层实际上是一个char[]数组：private final char value[];<br>用final修饰的对象值可变，但是引用不变，即：value指向不可变，但是value[]数组的值可变，<br>但因为有private关键字对其进行封装达到value[]数组值也不可变的目的</em>而StringBuffer对象的底层也是一个char[]数组：char[] value;<br>但是并没有用final修饰，所以数组的值是可变的。</p><p>##final意义：最终的，不可改变的。<br>　　1、修饰变量，为常量,值不可变；<br>　　2、修饰对象，值可变,引用不变；<br>　　3、修饰方法，方法不可重写；<br>　　4、修饰类，无子类，不可以被继承,更不可能被重写。</p><p>###12.18_day12总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###12.01_常见对象(Scanner的概述和方法介绍)(掌握)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:Scanner的概述&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B:Scanner的构造方法原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scanner(InputStream source)&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="String" scheme="http://zouyip.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://zouyip.github.io/2017/09/05/day10-%E5%86%85%E9%83%A8%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/05/day10-内部类笔记/</id>
    <published>2017-09-05T06:50:33.000Z</published>
    <updated>2017-10-25T01:36:55.341Z</updated>
    
    <content type="html"><![CDATA[<p>###10.01_面向对象(package关键字的概述及作用)(了解)</p><ul><li>A:为什么要有包<ul><li>将字节码(.class)进行分类存放 </li><li>包其实就是文件夹</li></ul></li><li>B:包的概述</li><li><p>  举例：</p><pre><code>学生：增加，删除，修改，查询老师：增加，删除，修改，查询...方案1：按照功能分    com.heima.add        AddStudent        AddTeacher    com.heima.delete        DeleteStudent        DeleteTeacher    com.heima.update        UpdateStudent        UpdateTeacher    com.heima.find        FindStudent        FindTeacher方案2：按照模块分    com.heima.teacher        AddTeacher        DeleteTeacher        UpdateTeacher        FindTeacher    com.heima.student        AddStudent        DeleteStudent        UpdateStudent        FindStudent</code></pre><p>###10.02_面向对象(包的定义及注意事项)(掌握)</p></li><li>A:定义包的格式<ul><li>package 包名;</li><li>多级包用.分开即可</li></ul></li><li>B:定义包的注意事项<ul><li>A:package语句必须是程序的第一条可执行的代码</li><li>B:package语句在一个java文件中只能有一个</li><li>C:如果没有package，默认表示无包名</li></ul></li><li>C:案例演示<ul><li>包的定义及注意事项</li></ul></li></ul><p>###10.03_面向对象(带包的类编译和运行)(掌握)</p><ul><li>A:如何编译运行带包的类<ul><li>a:javac编译的时候带上-d即可<ul><li>javac -d . HelloWorld.java</li></ul></li><li>b:通过java命令执行。<ul><li>java 包名.HellWord<br>###10.04_面向对象(不同包下类之间的访问)(掌握)</li></ul></li></ul></li><li>A:案例演示<ul><li>不同包下类之间的访问</li></ul></li></ul><p>###10.05_面向对象(import关键字的概述和使用)(掌握)</p><ul><li>A:案例演示<ul><li>为什么要有import<ul><li>其实就是让有包的类对调用者可见,不用写全类名了 </li></ul></li></ul></li><li>B:导包格式<ul><li>import 包名;</li><li>注意：</li><li>这种方式导入是到类的名称。</li><li>虽然可以最后写*，但是不建议。</li></ul></li><li>C:package,import,class有没有顺序关系(面试题)</li></ul><p>###10.06_面向对象(四种权限修饰符的测试)(掌握)</p><ul><li>A:案例演示<ul><li>四种权限修饰符</li></ul></li><li>B:结论</li><li><pre><code>            本类     同一个包下(子类和无关类)    不同包下(子类)    不同包下(无关类)private     Y        默认            Y        Yprotected    Y        Y                            Ypublic        Y        Y                            Y                Y</code></pre></li></ul><p>###10.07_面向对象(类及其组成所使用的常见修饰符)(掌握)</p><ul><li>A:修饰符：<ul><li>权限修饰符：private，默认的，protected，public</li><li>状态修饰符：static，final</li><li>抽象修饰符：abstract</li></ul></li><li><p>B:类：</p><ul><li>权限修饰符：默认修饰符，public</li><li>状态修饰符：final</li><li><p>抽象修饰符：abstract</p></li><li><p>用的最多的就是：public</p></li></ul></li><li><p>C:成员变量：</p><ul><li>权限修饰符：private，默认的，protected，public</li><li><p>状态修饰符：static，final</p></li><li><p>用的最多的就是：private</p></li></ul></li><li><p>D:构造方法：</p><ul><li><p>权限修饰符：private，默认的，protected，public</p></li><li><p>用的最多的就是：public</p></li></ul></li><li><p>E:成员方法：</p><ul><li>权限修饰符：private，默认的，protected，public</li><li>状态修饰符：static，final</li><li><p>抽象修饰符：abstract</p></li><li><p>用的最多的就是：public</p></li></ul></li><li><p>F:除此以外的组合规则：</p><ul><li>成员变量：public static final</li><li>成员方法：<ul><li>public static </li><li>public abstract</li><li>public final</li></ul></li></ul></li></ul><p>###10.08_面向对象(内部类概述和访问特点)(了解)</p><ul><li>A:内部类概述</li><li>B:内部类访问特点<ul><li>a:内部类可以直接访问外部类的成员，包括私有。</li><li>b:外部类要访问内部类的成员，必须创建对象。</li><li>外部类名.内部类名 对象名 = 外部类对象.内部类对象;（这种表述是为了让人看懂类中有内部类）</li></ul></li><li>C:案例演示<ul><li>内部类极其访问特点</li></ul></li></ul><p>###10.09_面向对象(成员内部类私有使用)(了解)</p><ul><li>private</li></ul><p>###10.10_面向对象(静态成员内部类)(了解)</p><ul><li>static</li><li>B:成员内部类被静态修饰后的访问方式是:<ul><li>外部类名.内部类名 对象名 = 外部类名.内部类对象;</li></ul></li></ul><p>###10.11_面向对象(成员内部类的面试题)(掌握)</p><ul><li>A:面试题</li><li><pre><code>要求：使用已知的变量，在控制台输出30，20，10。class Outer {    public int num = 10;    class Inner {        public int num = 20;        public void show() {            int num = 30;            System.out.println(?);            System.out.println(??);            System.out.println(???);        }    }}class InnerClassTest {    public static void main(String[] args) {        Outer.Inner oi = new Outer().new Inner();        oi.show();    }    }</code></pre></li></ul><p>###10.12_面向对象(局部内部类访问局部变量的问题)(掌握)</p><ul><li><p>A:案例演示</p><ul><li>局部内部类访问局部变量必须用final修饰</li><li><p>局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么?<br>  因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用</p><p>  但是jdk1.8取消了这个事情,所以我认为这是个bug</p></li></ul></li></ul><p>###10.13_面向对象(匿名内部类的格式和理解)</p><ul><li>A:匿名内部类<ul><li>就是内部类的简化写法。</li></ul></li><li>B:前提：存在一个类或者接口<ul><li>这里的类可以是具体类也可以是抽象类。</li></ul></li><li>C:格式：</li><li><pre><code>new 类名或者接口名(){    重写方法;}</code></pre></li><li>D:本质是什么呢?<ul><li>是一个继承了该类或者实现了该接口的子类匿名对象。</li></ul></li><li>E:案例演示<ul><li>按照要求来一个匿名内部类</li></ul></li></ul><p>###10.14_面向对象(匿名内部类重写多个方法调用)</p><ul><li>A:案例演示<ul><li>匿名内部类的方法调用</li></ul></li></ul><p>###10.15_面向对象(匿名内部类在开发中的应用)</p><ul><li>A:代码如下</li><li><pre><code>//这里写抽象类，接口都行abstract class Person {    public abstract void show();}class PersonDemo {    public void method(Person p) {        p.show();    }}class PersonTest {    public static void main(String[] args) {        //如何调用PersonDemo中的method方法呢?        PersonDemo pd = new PersonDemo ();    }}</code></pre></li></ul><p>###10.16_面向对象(匿名内部类的面试题)</p><ul><li>A:面试题</li><li><pre><code>按照要求，补齐代码interface Inter { void show(); }class Outer { //补齐代码 }class OuterDemo {    public static void main(String[] args) {          Outer.method().show();      }}要求在控制台输出”HelloWorld”</code></pre></li></ul><p>###10.17_day10总结</p><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###10.01_面向对象(package关键字的概述及作用)(了解)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:为什么要有包&lt;ul&gt;
&lt;li&gt;将字节码(.class)进行分类存放 &lt;/li&gt;
&lt;li&gt;包其实就是文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:包的概述&lt;/li&gt;

      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="内部类" scheme="http://zouyip.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>equals概述</title>
    <link href="http://zouyip.github.io/2017/09/05/day11-equals%E7%AC%94%E8%AE%B0/"/>
    <id>http://zouyip.github.io/2017/09/05/day11-equals笔记/</id>
    <published>2017-09-05T03:50:33.000Z</published>
    <updated>2017-10-25T01:44:17.902Z</updated>
    
    <content type="html"><![CDATA[<p>###_常见对象(API概述)(了解)</p><ul><li>A:API(Application Programming Interface) <ul><li>应用程序编程接口</li></ul></li><li>B:Java API<ul><li>就是Java提供给我们使用的类，这些类将底层的实现封装了起来，</li><li>我们不需要关心这些类是如何实现的，只需要学习这些类如何使用。</li></ul></li></ul><p>###_常见对象(Object类的概述)(了解)</p><ul><li>A:Object类概述<ul><li>类层次结构的根类</li><li>所有类都直接或者间接的继承自该类</li></ul></li><li>B:构造方法<ul><li>public Object()</li><li>回想面向对象中为什么说：</li><li>子类的构造方法默认访问的是父类的无参构造方法</li></ul></li></ul><p>###_常见对象(Object类的hashCode()方法)(了解)</p><ul><li>A:案例演示<ul><li>public int hashCode()</li><li>a:返回该对象的哈希码值。默认情况下，该方法会根据对象的地址来计算。</li><li>b:不同对象的，hashCode()一般来说不会相同。但是，同一个对象的hashCode()值肯定相同。</li></ul></li></ul><p>###_常见对象(Object类的getClass()方法)(在反射的时候掌握)</p><ul><li>A:案例演示<ul><li>public final Class getClass()</li><li>a:返回此 Object 的运行时类。</li><li>b:可以通过Class类中的一个方法，获取对象的真实类的全名称。    <ul><li>public String getName()</li></ul></li></ul></li></ul><p>###_常见对象(Object类的toString()方法)(掌握)</p><ul><li>A:案例演示<ul><li>public String toString()</li><li>a:返回该对象的字符串表示。</li></ul></li><li><pre><code>public Stirng toString() {    return name + &quot;,&quot; + age;}</code></pre><ul><li>b:它的值等于： <ul><li>getClass().getName() + “@” + Integer.toHexString(hashCode()) </li></ul></li><li>c:由于默认情况下的数据对我们来说没有意义，一般建议重写该方法。</li></ul></li><li>B:最终版<ul><li>自动生成</li></ul></li></ul><p>###_常见对象(Object类的equals()方法)(掌握)</p><ul><li>A:案例演示<ul><li>a:指示其他某个对象是否与此对象“相等”。 </li><li>b:默认情况下比较的是对象的引用是否相同。</li><li>c:由于比较对象的引用没有意义，一般建议重写该方法。</li></ul></li></ul><p>###_常见对象(==号和equals方法的区别)(掌握)</p><ul><li>==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值</li><li>equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,<br>  equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###_常见对象(API概述)(了解)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:API(Application Programming Interface) &lt;ul&gt;
&lt;li&gt;应用程序编程接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:Java API&lt;ul&gt;
&lt;li&gt;就是Jav
      
    
    </summary>
    
      <category term="java基础" scheme="http://zouyip.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="equals" scheme="http://zouyip.github.io/tags/equals/"/>
    
  </entry>
  
</feed>
